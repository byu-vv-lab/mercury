\section{Experiments}
The experiments compare the performance of the approach in this paper with two state-of-art MPI verifiers including MOPPER \cite{DBLP:conf/fm/ForejtKNS14}, a SAT based tool, and ISP \cite{DBLP:conf/ppopp/VakkalankaSGK08,DBLP:conf/sbmf/SharmaGB12}, a dynamic analyzer. 
As discussed earlier, MOPPER and our tool are designed to verify only single-path programs. To compare with ISP, it is meaningful only when the benchmarks are single-path.   
Therefore, a series of experiments are conducted for a set of single-path programs, including three small programs where each contains a deadlock, and seven typical benchmark programs. All the results show the comparison under infinite buffer semantics.  
%The computation is not included in each program because it is irrelevant to the problem of deadlock. 
The experiments are run on a AMD A8 Quad Core processor with 6 GB of memory running Ubuntu 14.04 LTS. We set a time limit of 30 minutes for each test. We abort the verification process if it does not complete within the time limit. 


\begin{savenotes}
\begin{table*}[t]
\begin{center}
\small
\caption{Tests on Selected Benchmarks}\label{table:benchmarks}
     \begin{threeparttable}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|}
		\hline
         \multicolumn{5}{|c|}{Test Programs} & \multicolumn{4}{c|}{Our Method} & \multicolumn{2}{c|}{ISP} & \multicolumn{2}{c|}{MOPPER}  \\ \hline
          $Name$ & \#Procs & \#Calls&Match&Deadlock &PT & PTR &D & Time & D &Time & D & Time\\ \hline
           \textit{dlg1} & 3 & 8 & 2  & Yes & 1& 0&$\surd$ & 0.009s & $\surd$ & 0.116s & $\surd$  & 0.001s\\ \hline
          \hline
           \textit{dlg5} & 3 & 16 & 12  & Yes &1&0 & $\surd$ & 0.021s & $\surd$ & 0.118s & $\surd$ & 0.002s\\ \hline
          \hline
           \textit{dlg8} & 3 & 12 & 4 & Yes &1& 0& $\surd$ & 0.019s & $\surd$ & 0.110s & $\surd$ & 0.002s\\ \hline
          \hline
          %\textit{Mismatch} & 3 & 12 & 2  & Yes  &1& & $\surd$ & 0.018s &  $\surd$ & 0.091s & $\surd$ & 0.002s\\ \hline
          %\hline
          
          %\textit{Circular} & 3 & 16 & 1  & Yes  &1& & $\surd$ & 0.004s & $\surd$ & 0.057s &  $\surd$ & 0.001s\\ \hline
          %\hline
          
          \multirow{3}{*}{\textit{Monte}} & 4 & 35 &  24 
          												     %& 0 & No & No\tnote{\textdagger} & 3.62 & 0.02s & 6 & 0.25s & 6.09 & $<$0.01s\\ \cline{5-13}
          						         & No  &0 &0 &  & 0.001s &  & 0.957s &  & 0.015s\\ \cline{2-13}
						       		& 8 & 75 &  40K 
          												     %& 0 & No & No\tnote{\textdagger} & 4.83 & 0.04s & $>$5K & TO & 11.28 & 0.02s\\ \cline{5-13}
          						        & No  &0&0 &  & 0.002s &  & TO &  & 0.751s\\ \cline{2-13}
						              & 16 & 155 &  2E13 
          												     %& 0 & No & No\tnote{\textdagger} & 8.97 & 0.29s & $>$5K & TO & 24.42 & 0.08s\\ \cline{5-13}
          						        & No  &0& 0& & 0.006s &  & TO &  & TO\\ \hline
						       \hline
						       
	   \multirow{3}{*}{\textit{Integrate}} & 8 & 36 &  5K
          												     %& 0 & Yes & No & 4.71 & 0.08s & 1 & 0.15s & --  & -- \tnote{a}\\ \cline{5-13}
          						        & No  &0 & 0&  & 0.001s &  & $>$1000s &  & 0.103s\\ \cline{2-13}
						       		& 10 & 46 & 362K
          												     %& 0 & Yes & No & 5.39 & 0.08s & 1 & 0.16s & -- & -- \tnote{a}\\ \cline{5-13}
          						        & No  &0&0 &  & 0.002s & & TO &  & 34.986s\\ \cline{2-13}
						              & 16 & 76 &  1E12
          												   %  & 0 & Yes & No & 8.79 & 0.62s & 1 & 0.25s & -- & -- \tnote{a}\\ \cline{5-13}
          						       & No  &0&0 & & 0.003s &  & TO & & TO\\ \hline
						       \hline
						       
	 %$\mathit{Integrate_m}$ & 10 & 46 & 362K
          												     %& 0 & Yes & No & 5.39 & 0.08s & 1 & 0.16s & -- & -- \tnote{a}\\ \cline{5-13}
          %						        & Yes  &1& $\surd$ & 0.024s & & TO & $\surd$ & 0.091s\\ \hline
		%					\hline
						       
	    \multirow{2}{*}{\textit{Diffusion2D}} & 4 & 52 & 6E9 
          												    % & 0 & No & Yes & 5.50 & 0.04s & 90 & 3.09s & 6.10 & 0.01s\\ \cline{5-13}
          						        & No  &0&0 &  & 0.003s &  & 32.005s &   & 0.039s\\ \cline{2-13}
						       		& 8 & 108 & 2E21 
          												     %& 0 & No & Yes & 11.94 & 0.22s & $>$9K & TO & -- & TO\\ \cline{5-13}
          						         & No  &0 &0 &  & 0.004s &  & TO &  & TO\\ \hline
						       \hline
						       
	    %  $\mathit{Diffusion2D_m}$ & 8 & 108 & 2E21 
          												     %& 0 & No & Yes & 11.94 & 0.22s & $>$9K & TO & -- & TO\\ \cline{5-13}
          	%					         & Yes  &1& $\surd$ & 0.036s &  & TO & $\surd$ & 0.362s\\ \hline        
		%				       \hline

						       
	    \multirow{2}{*}{\textit{Floyd}} & 8 & 120 &  4E29 
          												     %& 0 & No & No & 13.87 & 0.15s & $>$20K & TO & 18.05 & 0.27s\\ \cline{5-13}
          						        & No  &0 &0&  & 0.004s &  & TO &  & 2.812s\\ \cline{2-13}
						       		& 16 & 256 &  1E58 
          												    % & 0 & No & No & 21.58 & 0.26s & $>$20K & TO & 67.53 & 43.08s\\ \cline{5-13}
          						         & No  &0 & 0&  & 0.006s &  & TO &  & 62.467s\\ \hline
						        \hline
	    \multirow{2}{*}{\textit{GE}} & 8 & 56 & 64  
          												     %& 0 & No & No & 13.87 & 0.15s & $>$20K & TO & 18.05 & 0.27s\\ \cline{5-13}
          						        & No  &0 &0&  & 0.011s &  & 1.054s &  & 0.042s\\ \cline{2-13}
						       		& 16 & 120 & 16K  
          												    % & 0 & No & No & 21.58 & 0.26s & $>$20K & TO & 67.53 & 43.08s\\ \cline{5-13}
          						         & No  &0 & 0&  & 0.014s &  & 1.426s &  & 0.098s\\ \hline
						        \hline
			        
             
						        
	     \multirow{2}{*}{\textit{Mismatch}} & 3 & 400 & 100  & Yes  &50 &49 & $\surd$ & 1.609s  & $\surd$  & 4.274s & $\surd$ & 2.601s\\ \cline{2-13}
          					& 3 & 800 & 2E40  & Yes  &100& 98 & $\surd$ & 11.027s  & $\surd$ & 514.852s & $\surd$ & 17.892s\\ \hline
          \hline
          
           \textit{Circular} & 3 & 252 & 8E257  & Yes  & 132K & $\sim$132K & $\surd$ & 13.821s  &  & TO & $\surd$ & 728.722s\\ \hline

						                       
\end{tabular}
\end{threeparttable}
\end{center}
\end{table*}
\end{savenotes}

The results of the comparison are in \tableref{table:benchmarks}. The column ``Match" records the approximated number of match possibilities. A program with a large number of match possibilities has a large degree of message non-determinism. The column ``Deadlock" indicates the existence of deadlocks. The column ``PT" is the number of pattern instances that the algorithm in this paper detects. The column ``PTR" is the number of pattern instances that are pruned by the algorithm in this paper. The column ``D" indicates whether the tool detects a deadlock or not. The ``Time" column for our approach is the time of static analysis and constraint solving (if necessary). The ``Time" column of MOPPER is for constraint generation and solving. The column ``Time" for ISP is the running time of dynamic analysis. 

%The meaning of the symbol ``--" is ``unavailable": either the test is not interesting for comparison or the error is detected in preprocessing.
 
%\begin{compactitem}

\textit{dlg1, dlg5 and dlg8} implement simple message communication \cite{DBLP:conf/fm/ForejtKNS14}. Each contains a deadlock for mismatched send and receive pattern. 

\textit{Monte} implements the Monte Carlo method to compute $\pi$ \cite{benchmark:mentoCarlo}. It uses one manger process and multiple worker processes to send messages back and forth. In addition, barrier operations are used to synchronize the program. 

\textit{Integrate} uses heavy non-determinism in message communication to compute an integral of the $\sin$ function over the interval $[0, \pi]$ \cite{benchmark:fevs}. This benchmark also has a manger-worker pattern where the root process divides the interval to a certain number of tasks. It then distributes those tasks to multiple worker processes. 

%$\mathit{Integrate_m}$ is a variation of \textit{Integrate} such that it now has one instance of mismatched send-receive pattern. 
 
\textit{Diffusion2D} has an interesting computation pattern that uses barriers to ``partition" the message communication into several sections \cite{benchmark:fevs}. A message from a send can be only received in a common section. 

%$\mathit{Diffusion2D_m}$ is a variation of \textit{Diffusion2D}. It contains one instance of mismatched send-receive pattern.

\textit{Floyd} implements the shortest path algorithm for all the pairs of nodes \cite{DBLP:conf/ppopp/XueLWGCZZV09}. Each node communicates only with the immediate following neighbor.

\textit{GE} is a message passing implementation for Gaussian Elimination  \cite{DBLP:conf/ppopp/XueLWGCZZV09}. Messages are communicated by issuing several wildcard receives on each node. 

\textit{Mismatch} implements the message communication that contains a set of mismatched send and receive pattern. 

\textit{Circular} implements the message communication that contains a deadlock for circular dependency pattern.

%\end{compactitem}

The results show that the algorithm in this paper is highly efficient compared to ISP and MOPPER. For the small programs (e.g., \textit{dlg1}), all the tools correctly find the deadlocks and return very fast. For the large benchmark programs that do not have any deadlock (e.g., \textit{monte}), ISP runs much slower than the approach in this paper and MOPPER. For instance, it runs out of time when the program size of \textit{monte} increases to 8 processes. MOPPER runs fast when the number of processes is small, however, its runtime is largely increased as the number of processes increases. The approach in this paper, however, returns very fast even if the number of processes is large. This is because the approach in this paper does not need to run the SMT encoder as the algorithm detects no deadlock pattern instances. To test the efficiency of the schedule finder and the SMT encoder in this paper, the experiments include two large programs $\mathit{Mismatch}$ and $\mathit{Circular}$ that contain deadlocks for two patterns discussed in this paper. As shown in the results, the approach in this paper is able to prune massive number of infeasible deadlock patterns. For example, the program $\mathit{Circular}$ prunes about 132K infeasible pattern instances and detects a real deadlock. The results show that the algorithm in this paper is faster than ISP and MOPPER for the programs $\mathit{Mismatch}$ and $\mathit{Circular}$. As discussed earlier, our method may not find deadlocks that do not fit the patterns of mismatched send-receive or circular dependency. However, the experimental results show that our method is able to find all the deadlocks in the benchmark programs. This demonstrates that our method has a high coverage of deadlock detection. 

