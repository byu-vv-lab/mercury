\section{Experiments}
The experiments compare the performance of the approach in this paper with two state-of-art MPI verifiers MOPPER \cite{DBLP:conf/fm/ForejtKNS14}, a SAT based tool, and ISP \cite{DBLP:conf/ppopp/VakkalankaSGK08,DBLP:conf/sbmf/SharmaGB12}, a dynamic analyzer. 

Similar to the approach in this paper, MOPPER is designed to verify only single-path programs. ISP can be applied to both single-path programs and programs with branching. Therefore, it is meaningful only when the benchmarks are single-path.
%To compare with ISP, it is meaningful only when the benchmarks are single-path.   
A series of experiments are conducted for a set of single-path programs, including three small programs where each contains a deadlock, and seven typical benchmark programs. All the results show the comparison under infinite buffer semantics.  
%The computation is not included in each program because it is irrelevant to the problem of deadlock. 
The experiments are run on a AMD A8 Quad Core processor with 6 GB of memory running Ubuntu 14.04 LTS. A time limit of 30 minutes is set for each test. The test aborts the verification process if it does not complete within the time limit. 


\begin{savenotes}
\begin{table*}[t]
\begin{center}
\small
\caption{Tests on Selected Benchmarks}\label{table:benchmarks}
     \begin{threeparttable}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|}
		\hline
         \multicolumn{5}{|c|}{Test Programs} & \multicolumn{4}{c|}{Our Method} & \multicolumn{2}{c|}{ISP} & \multicolumn{2}{c|}{MOPPER}  \\ \hline
          $Name$ & \#Procs & \#Calls&Match&Deadlock &PT & PTR &D & Time & D &Time & D & Time\\ \hline
           \textit{dlg1} & 3 & 8 & 2  & Yes & 1& 0&$\surd$ & 0.009s & $\surd$ & 0.116s & $\surd$  & 0.001s\\ \hline
          \hline
           \textit{dlg5} & 3 & 16 & 12  & Yes &1&0 & $\surd$ & 0.021s & $\surd$ & 0.118s & $\surd$ & 0.002s\\ \hline
          \hline
           \textit{dlg8} & 3 & 12 & 4 & Yes &1& 0& $\surd$ & 0.019s & $\surd$ & 0.110s & $\surd$ & 0.002s\\ \hline
          \hline
          %\textit{Mismatch} & 3 & 12 & 2  & Yes  &1& & $\surd$ & 0.018s &  $\surd$ & 0.091s & $\surd$ & 0.002s\\ \hline
          %\hline
          
          %\textit{Circular} & 3 & 16 & 1  & Yes  &1& & $\surd$ & 0.004s & $\surd$ & 0.057s &  $\surd$ & 0.001s\\ \hline
          %\hline
          
          \multirow{3}{*}{\textit{Monte}} & 4 & 35 &  24 
          												     %& 0 & No & No\tnote{\textdagger} & 3.62 & 0.02s & 6 & 0.25s & 6.09 & $<$0.01s\\ \cline{5-13}
          						         & No  &0 &0 &  & 0.001s &  & 0.957s &  & 0.015s\\ \cline{2-13}
						       		& 8 & 75 &  40K 
          												     %& 0 & No & No\tnote{\textdagger} & 4.83 & 0.04s & $>$5K & TO & 11.28 & 0.02s\\ \cline{5-13}
          						        & No  &0&0 &  & 0.002s &  & TO &  & 0.751s\\ \cline{2-13}
						              & 16 & 155 &  2E13 
          												     %& 0 & No & No\tnote{\textdagger} & 8.97 & 0.29s & $>$5K & TO & 24.42 & 0.08s\\ \cline{5-13}
          						        & No  &0& 0& & 0.006s &  & TO &  & TO\\ \hline
						       \hline
						       
	   \multirow{3}{*}{\textit{Integrate}} & 8 & 36 &  5K
          												     %& 0 & Yes & No & 4.71 & 0.08s & 1 & 0.15s & --  & -- \tnote{a}\\ \cline{5-13}
          						        & No  &0 & 0&  & 0.001s &  & $>$1000s &  & 0.103s\\ \cline{2-13}
						       		& 10 & 46 & 362K
          												     %& 0 & Yes & No & 5.39 & 0.08s & 1 & 0.16s & -- & -- \tnote{a}\\ \cline{5-13}
          						        & No  &0&0 &  & 0.002s & & TO &  & 34.986s\\ \cline{2-13}
						              & 16 & 76 &  1E12
          												   %  & 0 & Yes & No & 8.79 & 0.62s & 1 & 0.25s & -- & -- \tnote{a}\\ \cline{5-13}
          						       & No  &0&0 & & 0.003s &  & TO & & TO\\ \hline
						       \hline
						       
	 %$\mathit{Integrate_m}$ & 10 & 46 & 362K
          												     %& 0 & Yes & No & 5.39 & 0.08s & 1 & 0.16s & -- & -- \tnote{a}\\ \cline{5-13}
          %						        & Yes  &1& $\surd$ & 0.024s & & TO & $\surd$ & 0.091s\\ \hline
		%					\hline
						       
	    \multirow{2}{*}{\textit{Diffusion2D}} & 4 & 52 & 6E9 
          												    % & 0 & No & Yes & 5.50 & 0.04s & 90 & 3.09s & 6.10 & 0.01s\\ \cline{5-13}
          						        & No  &0&0 &  & 0.003s &  & 32.005s &   & 0.039s\\ \cline{2-13}
						       		& 8 & 108 & 2E21 
          												     %& 0 & No & Yes & 11.94 & 0.22s & $>$9K & TO & -- & TO\\ \cline{5-13}
          						         & No  &0 &0 &  & 0.004s &  & TO &  & TO\\ \hline
						       \hline
						       
	    %  $\mathit{Diffusion2D_m}$ & 8 & 108 & 2E21 
          												     %& 0 & No & Yes & 11.94 & 0.22s & $>$9K & TO & -- & TO\\ \cline{5-13}
          	%					         & Yes  &1& $\surd$ & 0.036s &  & TO & $\surd$ & 0.362s\\ \hline        
		%				       \hline

						       
	    \multirow{2}{*}{\textit{Floyd}} & 8 & 120 &  4E29 
          												     %& 0 & No & No & 13.87 & 0.15s & $>$20K & TO & 18.05 & 0.27s\\ \cline{5-13}
          						        & No  &0 &0&  & 0.004s &  & TO &  & 2.812s\\ \cline{2-13}
						       		& 16 & 256 &  1E58 
          												    % & 0 & No & No & 21.58 & 0.26s & $>$20K & TO & 67.53 & 43.08s\\ \cline{5-13}
          						         & No  &0 & 0&  & 0.006s &  & TO &  & 62.467s\\ \hline
						        \hline
	    \multirow{2}{*}{\textit{GE}} & 8 & 56 & 64  
          												     %& 0 & No & No & 13.87 & 0.15s & $>$20K & TO & 18.05 & 0.27s\\ \cline{5-13}
          						        & No  &0 &0&  & 0.011s &  & 1.054s &  & 0.042s\\ \cline{2-13}
						       		& 16 & 120 & 16K  
          												    % & 0 & No & No & 21.58 & 0.26s & $>$20K & TO & 67.53 & 43.08s\\ \cline{5-13}
          						         & No  &0 & 0&  & 0.014s &  & 1.426s &  & 0.098s\\ \hline
						        \hline
			        
             
						        
	     \multirow{2}{*}{\textit{Mismatch}} & 3 & 400 & 100  & Yes  &50 &49 & $\surd$ & 1.609s  & $\surd$  & 4.274s & $\surd$ & 2.601s\\ \cline{2-13}
          					& 3 & 800 & 2E40  & Yes  &100& 98 & $\surd$ & 11.027s  & $\surd$ & 514.852s & $\surd$ & 17.892s\\ \hline
          \hline
          
           \textit{Circular} & 3 & 252 & 8E257  & Yes  & 132651 & 130804 & $\surd$ & 13.821s  &  & TO & $\surd$ & 728.722s\\ \hline

						                       
\end{tabular}
\end{threeparttable}
\end{center}
\end{table*}
\end{savenotes}

The results of the comparison are in \tableref{table:benchmarks}. The column ``Match" records the approximated number of match possibilities. A program with a large number of match possibilities has a large degree of message non-determinism. The column ``Deadlock" indicates the existence of deadlocks. The column ``PT" is the number of pattern instances that the algorithm in this paper detects. The column ``PTR" is the number of pattern instances that are pruned by the approach in this paper. The column ``D" indicates whether the tool detects a deadlock or not. The ``Time" column for the approach in this paper is the time of static analysis and constraint solving (if necessary). The ``Time" column of MOPPER is for constraint generation and solving. The column ``Time" for ISP is the running time of dynamic analysis. The notation ``TO" means ``time out" (exceeding the time limit set for each test).

%The meaning of the symbol ``--" is ``unavailable": either the test is not interesting for comparison or the error is detected in preprocessing.
 
%\begin{compactitem}
The experiments are launched for a set of benchmarks. The small test includes \textit{dlg1, dlg5 and dlg8} that implement simple message communications \cite{DBLP:conf/fm/ForejtKNS14}. Each contains a deadlock for the orphaned receive pattern.  

The typical benchmarks are tested as well. \textit{Monte} implements the Monte Carlo method to compute $\pi$ \cite{benchmark:mentoCarlo}. It uses one manger process and multiple worker processes to send messages back and forth. In addition, barrier operations are used to synchronize the program. 

\textit{Integrate} uses heavy non-determinism in message communication to compute an integral of the $\sin$ function over the interval $[0, \pi]$ \cite{benchmark:fevs}. This benchmark also has a manger-worker pattern where the root process divides the interval to a certain number of tasks. It then distributes those tasks to multiple worker processes. 

%$\mathit{Integrate_m}$ is a variation of \textit{Integrate} such that it now has one instance of mismatched send-receive pattern. 
 
\textit{Diffusion2D} has an interesting computation pattern that uses barriers to ``partition" the message communication into several sections \cite{benchmark:fevs}. A message from a send can be only received in a common section. 

%$\mathit{Diffusion2D_m}$ is a variation of \textit{Diffusion2D}. It contains one instance of mismatched send-receive pattern.

\textit{Floyd} implements the shortest path algorithm for all the pairs of nodes \cite{DBLP:conf/ppopp/XueLWGCZZV09}. Each node communicates only with the immediate following neighbor.

\textit{GE} is a message passing implementation for Gaussian Elimination  \cite{DBLP:conf/ppopp/XueLWGCZZV09}. Messages are communicated by issuing several wildcard receives on each node. 

\textit{Mismatch} implements the message communication that contains a set of the orphaned receive pattern. 

\textit{Circular} implements the message communication that contains a deadlock for the circular dependency pattern.

%\end{compactitem}

The results show that the algorithm in this paper is more efficient than ISP and MOPPER. For the small programs (e.g., \textit{dlg1}), all the tools correctly find the deadlocks and return very fast. For the large benchmark programs that do not have any deadlock (e.g., \textit{monte}), ISP runs much slower than MOPPER and the approach in this paper. For instance, it runs out of time when the program size of \textit{monte} increases to 8 processes. MOPPER runs fast when the number of processes is small, however, it may time out with a large the number of processes. The approach in this paper, however, returns very fast even with a large number of processes. This is because it  does not need to check feasibility or validate any pattern instances once it detects no instances are matched. 
For the large benchmark programs with deadlocks, the approach in this paper remains faster than other tools, even though the higher cost SMT encoding is used this time. 
Also, the approach in this paper is able to prune a large number of non-feasible pattern instances. For example, the program $\mathit{Circular}$ prunes 130804 non-feasible pattern instances out of 132651 instances and detects a real deadlock. 

