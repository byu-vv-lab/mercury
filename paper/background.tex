\section{Background}
This presentation uses a CTP syntax with semantics loosely based on MPI semantics for convenience. In an MPI program, it is assumed that only non-blocking sends and receives are used. A non-blocking operation is simply consumed in program execution.
%% introduce the language aspects: non-blocking, blocking, barrier, collective, point-to-point in the introduction.
In general, the syntax of an MPI program is presented in \figref{fig:expr:stx} (a). The syntax describes a concurrent trace program (CTP). The presentation uses ellipses ($\ldots$) to represent zero or more repetitions, bold-face to indicate terminals. The language defines a CTP (\textit{ctp}) as a list of processes.  A process (\thread) is a list of commands.  For simplicity, commands (\textit{e}) are restricted to non-blocking send (\sendi), non-blocking receive (\recvi), wait (\wait) and barrier (\barrier). Each command is a tuple. It is referred to each tuple as a single notation $\mathtt{o_c}$ in the following discussion, where $\mathtt{o}\in\{\sendi,\recvi,\wait,\barrier\}$ and $\mathtt{c}$ is the line number.  
The non-terminal \aid\ in the grammar is a unique string identifier \textbf{ID} associated with a receive or a wait. The wait takes a second identifier belonging to the associated receive. Similarly, a receive is paired with a wait by recording the identifier of this wait in the tuple. It is assumed that a message is sent out immediately once the non-blocking send is issued, therefore, it is not necessary to associate an identifier or a wait with the send. A barrier \barrier\ is also associated with an identifier that is unique for its communicator. A communicator identifies a group of barriers. The non-terminal \num\ in the grammar is a number that represents an endpoint. To be precise, a receive (or a send) is associated with a source endpoint and a destination endpoint. Note that if the source endpoint of a receive is $\ast$, this receive is a wildcard receive meaning it may be matched with a send from any source. The set \rcvp\ is a deadlock pattern instance that consists of a set of receives. The patterns are defined in the following section. The data and computation are ignored since only message communication is considered in the problem of deadlock. 

\newsavebox{\boxLangSyntax}

\begin{lrbox}{\boxLangSyntax}
\begin{minipage}[c]{0.3\linewidth}
\cfgstart
\cfgrule{ctp}{\lp\cfgnt{\thread}$~\ldots$\rp}
\cfgrule{\thread}{\lp\cfgnt{\cmd}~$\ldots$~$\bot$\rp}
\cfgrule{\cmd}{\lp\cfgt{\sendi}~\cfgt{\num}~\cfgt{\num}\rp}
   \cfgorline{\lp\cfgt{\recvi}~\cfgt{\aid}~\cfgt{\num}~\cfgt{\num}~\cfgt{\aid}\rp}
   \cfgorline{\lp\cfgt{\wait}~\cfgt{\aid}~\cfgt{\aid}\rp}
   \cfgorline{\lp\cfgt{\barrier}~\cfgt{\aid}\rp}
\cfgrule{\num}{\cfgt{number}}
\cfgrule{\rcvp}{\lp\aid~$\ldots$\rp}
\cfgrule{\npro}{\cfgt{number}}
\cfgrule{\aid}{\cfgt{ID}}
\cfgend
\end{minipage}
\end{lrbox}


\newsavebox{\boxEvalSyntax}
\begin{lrbox}{\boxEvalSyntax}
\begin{minipage}[c]{0.3\linewidth}
\cfgstart
\cfgrule{st}{\lp\cfgnt{ctp}\ \cfgnt{ctp}\ \cfgnt{\epsnd}\ \cfgnt{\eprcv}\ \cfgnt{\epwait}\ \cfgnt{\epbarrier}\ \rcvp\rp}
\cfgrule{\epsnd}{\cfgt{\mt}\
   \cfgor\lp\cfgnt{\epsnd}~\lb\lp\cfgt{\num},\cfgt{\num}\rp~$\rightarrow$~\cfgt{\num}\rb\rp}
\cfgrule{\eprcv}{\cfgt{\mt}\
   \cfgor\lp\cfgnt{\eprcv}~\lb\lp\cfgt{\num},\cfgt{\num}\rp~$\rightarrow$~\cfgt{\num}\rb\rp}
\cfgrule{\epwait}{\cfgt{\mt}\
   \cfgor\lp\cfgnt{\epwait}~\lb\cfgnt{\aid}~$\rightarrow$~\cfgnt{rcv}\rb\rp}
\cfgrule{rcv}{\lp\lb\cfgt{\aid}~\cfgt{\num}~\cfgt{\num}\rb\ \ldots\rp}
\cfgrule{\epbarrier}{\cfgt{\mt}\
   \cfgor\lp\cfgnt{\epbarrier}~\lb\cfgnt{\aid}~$\rightarrow$~\cfgt{\num}\rb\rp}
\cfgend
\end{minipage}
\end{lrbox}

\begin{figure}
\begin{center}
\setlength{\tabcolsep}{15pt}
\begin{tabular}{cc}
\scalebox{0.75}{\usebox{\boxLangSyntax}}
&
\scalebox{0.75}{\usebox{\boxEvalSyntax}}
\\ \\
(a) & (b)
\end{tabular}
\end{center}
\caption{The language syntax with its evaluation syntax for the operational semantics--bold face indicates a terminal. (a) The input syntax. (b) The evaluation syntax.}
\label{fig:expr:stx}
\end{figure}

%%TODO: may move the machine state to where presenting the abstract machine.

The operational semantics for the language are given by a term rewriting system using a \textit{CESK} style machine \footnote{The \textit{CESK} machine state is represented with a \textbf{C}ontrol string, \textbf{E}nvironment, \textbf{S}tore, and \textbf{K}ontinuation.}. \figref{fig:expr:stx}(b) defines the machine state and other syntax relating to evaluation. The machine state (\textit{st}) is a seven-tuple of variables. The first variable \textit{ctp} defines the trace program. The second variable \textit{ctp} represents a generated schedule that is initialized as an empty set $((\bot) (\bot) \ldots)$. The set \epsnd\ maps a destination endpoint and a source endpoint to a number that is used to record the number of the issued sends. The variable \eprcv\ has the same structure only the number is used to record the number of the matched receives. The variable \epwait\ records the pending receives by mapping the unique identifier of a nearest-enclosing wait to a set of the issued receives $\mathit{rcv}$. A nearest-enclosing wait witnesses the completion of a receive by indicating that the message is delivered and that all the previous receives on the same process issued earlier are complete as well. In this set, the action identifier, the source endpoint and the destination endpoint are recorded for each receive. The variable \epbarrier\ maps the unique identifier of a communicator to a number that is used to record the number of the witnessed barriers.
