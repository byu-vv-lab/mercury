\section{Concurrent Trace Programs}
This paper only considers non-determinism arising from message races and defines MPI program semantics in the context of concurrent trace programs (CTP) \cite{DBLP:conf/sigsoft/WangCGY09}. 
%In an MPI program, it is assumed that only non-blocking sends and receives are used. A non-blocking operation is issued without blocking the program execution. It is usually paired with a wait function that witnesses the completion of this non-blocking operation.
%% introduce the language aspects: non-blocking, blocking, barrier, collective, point-to-point in the introduction.
The syntax is in \figref{fig:expr:stx} (a). Lists use white space rather than commas to delineate members, ellipses ($\ldots$) represent zero or more repetitions, and bold-face font denotes terminals in the language.

A CTP (\textit{ctp}) is a list of processes.  A process (\thread) is a list of commands. The commands (\textit{e}) are: non-blocking send (\sendi), non-blocking receive (\recvi), wait (\wait), and barrier (\barrier). 
The non-terminal \aid\ in the grammar is a unique string identifier \textbf{ID} associated with a receive, a send, or a wait. 
A receive indicates both its unique ID and the unique
ID of its associated wait. That wait by definition is its
nearest-enclosing wait (i.e., the first wait that witnesses the receive
complete).
%The MPI semantics use an infinite buffer, therefore, a non-block send is issued immediately. As such, it is not necessary to associate an identifier or a wait with the send. 
A barrier \barrier\ is also associated with an identifier that is unique for its communicator. The communicator identifies a group of barrier commands and can only be used one time. Processes block at the barrier commands until all members in the communicator arrive.
The non-terminal \num\ in the grammar is used to denote endpoints, and it can be $\ast$ to indicate any endpoint. The receive and send commands include source and destination endpoints for communication. In the case of receive, the source may be $\ast$ indicating that the receive can match with any send to the same destination regardless of the source. The $\ast$ may not be used anywhere else in the program. The rest of the presentation assumes only well-formed programs as input.

A pattern instance (\rcvp) is a list of IDs indicating unique receive commands. Each process has at most one
receive ID in the list. If a process has a receive ID in the list, then the receive attached to the ID marks a point of execution in
the owning process. The intuition is that if each process is able to
arrive at the indicated point of execution in the pattern instance, then a deadlock is imminent.


%\figref{fig:deadlock2} shows an example of a CTP with three processes. 

%Consider extending the syntax for data and computation so can use it for other errors





\newsavebox{\boxLangSyntax}

\begin{lrbox}{\boxLangSyntax}
\begin{minipage}[c]{0.3\linewidth}
\cfgstart
\cfgrule{ctp}{\lp\cfgnt{\thread}$~\ldots$\rp}
\cfgrule{\thread}{\lp\cfgnt{\cmd}~$\ldots$~$\bot$\rp}
\cfgrule{\cmd}{\lp\cfgt{\sendi}~\cfgt{\aid}~\cfgt{\num}~\cfgt{\num}\rp}
   \cfgorline{\lp\cfgt{\recvi}~\cfgt{\aid}~\cfgt{\num}~\cfgt{\num}~\cfgt{\aid}\rp}
   \cfgorline{\lp\cfgt{\wait}~\cfgt{\aid}\rp}
   \cfgorline{\lp\cfgt{\barrier}~\cfgt{\aid}\rp}
\cfgrule{\num}{\cfgt{number}}\
    \cfgorline{\cfgt{$\ast$}}
\cfgrule{\rcvp}{\lp\aid~$\ldots$\rp}
%\cfgrule{\npro}{\cfgt{number}}
\cfgrule{\aid}{\cfgt{ID}}
\cfgend
\end{minipage}
\end{lrbox}


\newsavebox{\boxEvalSyntax}
\begin{lrbox}{\boxEvalSyntax}
\begin{minipage}[c]{0.3\linewidth}
\cfgstart
\cfgrule{st}{\lp\cfgnt{ctp}\ \cfgnt{\epsnd}\ \cfgnt{\eprcv}\ \cfgnt{\epwait}\ \cfgnt{\epbarrier}\ \rcvp\rp}
\cfgrule{\epsnd}{\cfgt{\mt}\
   \cfgor\lp\cfgnt{\epsnd}~\lb\lp\cfgt{\num}\ \cfgt{\num}\rp~$\rightarrow$~\cfgt{\num}\rb\rp}
\cfgrule{\eprcv}{\cfgt{\mt}\
   \cfgor\lp\cfgnt{\eprcv}~\lb\lp\cfgt{\num}\ \cfgt{\num}\rp~$\rightarrow$~\cfgt{\num}\rb\rp}
\cfgrule{\epwait}{\cfgt{\mt}\
   \cfgor\lp\cfgnt{\epwait}~\lb\cfgnt{\aid}~$\rightarrow$~\cfgnt{rcv}\rb\rp}
\cfgrule{rcv}{\lp\lb\cfgt{\aid}~\cfgt{\num}~\cfgt{\num}\rb\ \ldots\rp}
\cfgrule{\epbarrier}{\cfgt{\mt}\
   \cfgor\lp\cfgnt{\epbarrier}~\lb\cfgnt{\aid}~$\rightarrow$~\cfgt{\num}\rb\rp}
\cfgend
\end{minipage}
\end{lrbox}

\begin{figure}
\begin{center}
\setlength{\tabcolsep}{15pt}
\begin{tabular}{cc}
\scalebox{0.75}{\usebox{\boxLangSyntax}}
&
\scalebox{0.75}{\usebox{\boxEvalSyntax}}
\\ \\
(a) & (b)
\end{tabular}
\end{center}
\caption{The language syntax with its evaluation syntax for the abstract machine in \figref{fig:machine} -- bold face indicates a terminal. (a) The input syntax. (b) The evaluation syntax.}
\label{fig:expr:stx}
\end{figure}

\examplefigthree


%%TODO: may move the machine state to where presenting the abstract machine.


