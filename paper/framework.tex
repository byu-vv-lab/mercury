\section{Main Framework}

%%The general algorithm including three steps: Pattern Match, Feasible Check and Validation. The pseudocode needs to be revised so it shows each step. 

\algoref{algo:main} describes the general structure of the approach in this presentation which consists of three distinct steps: pattern matching (line 1), feasibility checking (line 3), and validating (line 6). $\mathrm{PATTERNMATCH}$ statically generates a set ($\mathit{PT}$) of matched pattern instances in the \emph{ctp} with the help of an additional input, $M$, that defines all the potential match-pairs in the program. $M$ can be generated in quadratic time \cite{DBLP:conf/kbse/HuangMM13}. 

$\mathrm{FEASIBLECHECK}$ is an abstract machine to prune pattern instances for which it is possible to prove that no feasible schedule exists. In other words, it is provably not possible to execute the \emph{ctp} such that each process associated with a receive ID in the pattern instance is at that receive. The machine removes matched receive IDs from the pattern instance as it executes the \emph{ctp}, so if $\mathit{pt^\prime}$ is not empty upon return, the pattern instance is provably not feasible and the algorithm continues with the next pattern instance (line 5). The algorithm additionally returns the number of issued sends ($\mathit{N_s}$) and the number of issued receives ($\mathit{N_r}$). These are used in validation depending on the type of the pattern instance: circular dependency or orphaned receive.

%The framework is useful for error detection with appropriate pattern match and validation algorithms. This paper applies the framework for deadlock detection based on two types of deadlock patterns in the next two sections.

\begin{algorithm}[t]
\caption{Main Framework}\label{algo:main}
\begin{algorithmic}[1]
%\Procedure{Main Entrance}{}
%\Require $\mathit{ctp}$, a single-path MPI program
%\Require $\mathit{M}(\mathtt{r_c}) = \{\mathtt{s_l}\mid(\mathtt{s_l},\mathtt{r_c})\in\mathit{M}\}$, a set of potentially matched sends for $\mathtt{r_c}$
%\State  $\mathit{PT}$, a set of pattern instances
%\State  $\mathit{pt}$, a set of receives in the pattern instance $\mathit{pt}\in\mathit{PT}$
\State  $\mathit{PT} \gets$ \Call {PatternMatch}{$\mathit{ctp}$, $\mathit{M}$}
\For{$\mathit{pt} \in \mathit{PT}$}
\State ($\mathit{N_s}, \mathit{N_r}, \mathit{pt^\prime})\gets$\Call {FeasibleCheck}{$\mathit{pt}$, $\mathit{ctp}$}
\If{$\mathit{pt^\prime} \neq \emptyset$}
\State continue.
\ElsIf{$\neg$\Call {Validate}{$\mathit{N_s}, \mathit{N_r}, \mathit{pt}$}}
\State continue.
\Else\ report error and exit.
\EndIf

%\State ($\mathit{ctp}_s, \mathit{N_s}, \mathit{N_r}, \mathit{empty}_{pt}) \gets$ \Call {ScheduleFinder}{$\mathit{pt}$}
%\If{$\mathit{empty}_{pt}$} 
%\If{\Call{isCircular}{$\mathit{pt}$}}
%\For{$\mathtt{r_c}\in\mathit{pt}$}
%\State $\mathit{src} \gets$ source endpoint of $\mathtt{r_c}$, $\mathit{dest} \gets$ destination endpoint of $\mathtt{r_c}$
%\If{$\mathit{N_s}(\mathit{dest},\mathit{src}) > \mathit{N_r}(\mathit{dest},\mathit{src})$}
%\State \textbf{continue} \textit{point}
%\EndIf
%\EndFor
%\State report deadlock and exit.
%\EndIf
%\If{\Call {isMismatch}{$\mathit{pt}} \in$}
%\If{\textproc{SAT}({\Call {Encode}{$\mathit{ctp}_s$}})}
%\State report deadlock and exit.
%\EndIf
%\EndIf
%\EndIf
\EndFor
%\EndProcedure
\end{algorithmic}
\end{algorithm}

%%The feasible check and the soundness proof of feasible check (assuming pattern match is sound and validation is sound and complete)

$\mathrm{VALIDATE}$ proves a pattern instance feasible, which means that it is a real deadlock in the \emph{ctp}. If the deadlock is real, the algorithm reports the error and exits (line 8); otherwise it continues with the next pattern instance.

\textrm{FEASIBLECHECK} is able to efficiently prune schedules that are provably non-feasible with predictive analysis using counting and  auxiliary data structures to track FIFO ordering on messages. 

\figref{fig:machine} is a term rewriting system for a syntactic
machine (i.e., the machine state is represented by a string) for
$\mathrm{FEASIBLECHECK}$ to prove that a pattern instance is not
feasible. \figref{fig:expr:stx}(b) is the syntax for that machine. The
rewrites define how the machine executes an input \emph{ctp} and
pattern instance \emph{pt} by evolving the machine state. At a high-level, the machine can
\begin{compactitem}
\item Process a send, receive, or barrier from a process by counting the send (\emph{Sndi Command}), queuing up the receive on the indicated wait ID (\emph{Rcvi Command}), or counting the barrier (\emph{Barrier Command 1}).
\item Consume a wait from a process when the associated queue is empty (\emph{Wait (Rcvi) Command 1})
\item Remove a receive ID from the pattern instance and suspend the indicated wait when the associated receive is next on the queue for the wait (\emph{Wait (Rcvi) Command 2}).
\item Remove the next receive from the queue for the indicated wait and update the number of receives when feasible (\emph{Wait (Rcvi) Command 3}).
\item Consume a barrier if all the processes have arrived (\emph{Barrier Command 2}) -- communicator groups may only be used once.
\end{compactitem}
At a lower-level, the machine state (\textit{st}) is a six-tuple of variables. The first variable \textit{ctp} defines the concurrent trace program being analyzed. The set \epsnd\ maps a destination endpoint and a source endpoint to a number that is used to count issued sends. The variable \eprcv\ has the same structure only the number is used to count the number of matched receives. The variable \epwait\ records the pending receives by mapping the unique identifier of a wait to a queue of the issued receives $\mathit{rcv}$. 
%A nearest-enclosing wait is the first wait that witnesses the completion of a receive by indicating that the message is delivered and that all the previous receives on the same process issued earlier are complete as well. 
In this queue, the action identifier, the source endpoint and the destination endpoint are recorded for each receive. The variable \epbarrier\ maps the unique identifier of a communicator to a number that is used to count the number of witnessed barriers.

\begin{figure*}[tb]
\centering
\scalebox{0.9}{
\mprset{flushleft}
\begin{mathpar}

\inferrule[Sndi Command]{
  \epsnd(v_{to},v_{frm}) = v_c \\ \epsnd(v_{to},\ast) = v_i  \\ \epsnd^\prime = \epsnd[(v_{to},v_{frm}) \mapsto v_c +1,\ (v_{to},\ast) \mapsto v_i+1] \\ 
  %\epsnd^{\prime\prime} = \epsnd^\prime[\forall v\ldotp \epsnd(v_{to},v) = v_i \mid (v_{to},v) \mapsto v_i +1] 
 %\epsnd(v_{to},\ast) = v_i \\ \epsnd^{\prime\prime} = \epsnd^\prime[(v_{to},\ast) \mapsto v_i +1] 
}{
  ((\thread_0\ \ldots\ ((\sendi\ \aid\ v_{frm}\ v_{to})\ \cmd_1\ \ldots\ \bot)\ \thread_2\ \ldots)\ \epsnd\ \eprcv\ \epwait\ \epbarrier\ \rcvp) \reduce{m}
  ((\thread_0\ \ldots\ (\cmd_1\ \ldots\ \bot)\ \thread_2\ \ldots)\ \epsnd^{\prime}\ \eprcv\ \epwait\ \epbarrier\ \rcvp)
}

\and

\inferrule[Rcvi Command]{
 \epwait(\aid_w) =  ([\aid_1\ v_{frm1}\ v_{to1}]\ \ldots)
 \\ \epwait^\prime = \epwait [ \aid_w \mapsto ([\aid_1\ v_{frm1}\ v_{to1}]\ \ldots\ [\aid_0\ v_{frm0}\ v_{to0}])] 
}{
  ((\thread_0\ \ldots\ ((\recvi\ \aid_0\ v_{frm0}\ v_{to0}\ \aid_w)\ \cmd_1\ \ldots\ \bot)\ \thread_2\ \ldots)\ \epsnd\ \eprcv\ \epwait\ \epbarrier\ \rcvp) \reduce{m}
  ((\thread_0\ \ldots\ (\cmd_1\ \ldots\ \bot)\ \thread_2\ \ldots)\ \epsnd\ \eprcv\ \epwait^\prime\ \epbarrier\ \rcvp)
}
\and
\inferrule[Wait (rcvi) Command 1]
{
  \epwait(\aid_w) = ()
}{
  ((\thread_0\ \ldots\ ((\wait\ \aid_w)\ \cmd_1\ \ldots\ \bot)\ \thread_2\ \ldots)\ \epsnd\ \eprcv\ \epwait\ \epbarrier\ \rcvp) \reduce{m}
  ((\thread_0\ \ldots\ (\cmd_1\ \ldots\ \bot)\ \thread_2\ \ldots)\ \epsnd\ \eprcv\ \epwait\ \epbarrier\ \rcvp)
}
\and
\inferrule[Wait (rcvi) Command 2]
{
   \epwait(\aid_w) = ([\aid_0\ v_{frm0}\ v_{to0}]\ [\aid_1\ v_{frm1}\ v_{to1}]\ \ldots) \\ \rcvp = (\aid_a\ \ldots\ \aid_0\ \aid_b\ \ldots) \\ \aid_0 \in \rcvp \\ \rcvp^\prime = (\aid_a\ \ldots\ \aid_b\ \ldots)
}{
  ((\thread_0\ \ldots\ ((\wait\ \aid_w)\ \cmd_1\ \ldots\ \bot)\ \thread_2\ \ldots)\ \epsnd\ \eprcv\ \epwait\ \epbarrier\ \rcvp) \reduce{m}
  ((\thread_0\ \ldots\ ((\ast\wait\ \aid_w)\ \cmd_1\ \ldots\ \bot)\ \thread_2\ \ldots)\ \epsnd\ \eprcv\ \epwait\ \epbarrier\ \rcvp^\prime)
}
\and
\inferrule[Wait (rcvi) Command 3]
{
  \epwait(\aid_w) = ([\aid_0\ v_{frm0}\ v_{to0}]\ [\aid_1\ v_{frm1}\ v_{to1}]\ \ldots) \\
  \aid_0 \notin \rcvp \\ \eprcv(v_{to0},v_{frm0}) < \epsnd(v_{to0},v_{frm0}) \\ \eprcv(v_{to0},\ast) < \epsnd(v_{to0},\ast) \\
   \eprcv(v_{to0},v_{frm0}) = v_c \\
    \eprcv^\prime = \eprcv [(v_{to0}, v_{frm0}) \mapsto v_c + 1] \\ 
    \epwait^\prime = \epwait [\aid_w\ \mapsto\ ([\aid_1\ v_{frm1}\ v_{to1}]\ \ldots)]
}{
  ((\thread_0\ \ldots\ ((\wait\ \aid_w)\ \cmd_1\ \ldots\ \bot)\ \thread_2\ \ldots)\ \epsnd\ \eprcv\ \epwait\ \epbarrier\ \rcvp) \reduce{m}
  ((\thread_0\ \ldots\ ((\wait\ \aid_w)\ \cmd_1\ \ldots\ \bot)\ \thread_2\ \ldots)\ \epsnd\ \eprcv^\prime\ \epwait^\prime\ \epbarrier\ \rcvp)
}
\and
\inferrule[Barrier Command 1]
{
  \epbarrier(\aid_0) = v_c \\ v_c < N_{proc} \\ \epbarrier^\prime = \epbarrier[\aid_0 \mapsto  v_c + 1]
}{
 ((\thread_0\ \ldots\ ((\barrier\ \aid_0)\ \cmd_1\ \ldots\ \bot)\ \thread_2\ \ldots)\ \epsnd\ \eprcv\ \epwait\ \epbarrier\ \rcvp) \reduce{m}
 ((\thread_0\ \ldots\ ((\ast\barrier\ \aid_0)\ \cmd_1\ \ldots\ \bot)\ \thread_2\ \ldots)\ \epsnd\ \eprcv\ \epwait\ \epbarrier^\prime\ \rcvp)
}
\and
\inferrule[Barrier Command 2]
{
  \epbarrier(\aid_0) = N_{proc}
}{
 ((\thread_0\ \ldots\ ((\ast\barrier\ \aid_0)\ \cmd_1\ \ldots\ \bot)\ \thread_2\ \ldots)\ \epsnd\ \eprcv\ \epwait\ \epbarrier\ \rcvp) \reduce{m}
 ((\thread_0\ \ldots\ (\cmd_1\ \ldots\ \bot)\ \thread_2\ \ldots)\ \epsnd\ \eprcv\ \epwait\ \epbarrier\ \rcvp)
}

\end{mathpar}}
\caption{Machine reductions ($\reduce{m}$). }
\label{fig:machine}
\end{figure*}

The \emph{Sndi Command} in \figref{fig:machine} consumes sends in a process. 
$\epsnd^\prime$\ is a new set, just like the old set $\epsnd$, only the new set maps the destination
endpoint $v_{to}$\ and the source endpoint $v_{frm}$ to the number $v_c + 1$ where $v_c$ is the value in the old set on the same $(v_{to},v_{frm})$ key. 
It also maps $v_{to}$\ and $\ast$ to the number $v_i + 1$ where $v_i$ is the value in the old set on the same $(v_{to},\ast)$ key. As mentioned previously, the notation $\ast$ is a special source endpoint indicating any source.

The \emph{Rcvi Command} in \figref{fig:machine} consumes receives by updating \epwait. 
Similar to the rule \emph{Sndi Command}, \epwait\ merely inserts a new record for the receive $x_0$ to the tail of the queue indexed by the 
wait that witnesses the completion of $x_0$.

The \emph{Wait (Rcvi) Command} operates in three ways. 
If the wait $\aid_w$ maps to an empty queue in \epwait, indicating that no receives need to be completed by $\aid_w$, then $\aid_w$ is simply consumed (\emph{Wait (Rcvi) Command 1}). 

If the next receive $\aid_0$ in the queue $\epwait(\aid_w)$ is found in \rcvp\ where the notation $\in$ is used to indicate this condition, then $\aid_0$ is removed from \rcvp\ and the wait $\aid_w$ is suspended in a process by replacing the notation \wait\ with $\ast$\wait, meaning that $\aid_0$ in \rcvp\ is reached and this process blocks at $\aid_w$ in execution.

(\emph{Wait (Rcvi) Command 2}). 

The last rule for wait (\emph{Wait (Rcvi) Command 3}) checks whether the next receive $\aid_0$\ in the queue $\epwait(x_w)$ is able to be consumed. The rule is only active if $\aid_0$ is not in \rcvp. The rule requires two conditions: 
\[\eprcv(v_{to0},v_{frm0}) < \epsnd(v_{to0},v_{frm0})\]
checks whether there are more counted sends than counted receives with common source and destination endpoints,
and 
\[\eprcv(v_{to0},\ast) < \epsnd(v_{to0},\ast)\]
checks whether there are more counted sends than counted receives for any preceding wildcard receives. These conditions indicate that at least one send can be matched with $\aid_0$. If both conditions hold, then \eprcv\ is updated with the counted receive, and $\aid_0$ is removed from \epwait. 

The \emph{Barrier Command} moves the barrier forward by its synchronization rule. It is assumed that the group of any barrier consists of all the processes in the $\mathit{ctp}$. 
If the count of the witnessed barriers $\epbarrier(\aid_0)$ for a specific communicator $\aid_0$ is less than the total number of the processes ($N_{proc}$), indicating that the barriers for $\aid_0$ are not matched, then the barrier is not consumed. Rather, the barrier is counted by incrementing $\epbarrier(\aid_0)$ and replacing the notation \barrier\ with $\ast$\barrier\ for the same communicator in the $\mathit{ctp}$ (\emph{Barrier Command 1}). 

If $\epbarrier(\aid_0)$ is equal to $N_{proc}$ indicating that all the barriers for $\aid_0$ are matched, then they can be consumed (\emph{Barrier Command 2}).

The machine rewrites the state until no more reduction rules can be applied indicating that there is no way to further execute the program. The first statement that cannot be consumed on any process is either the bottom of the process or a blocking command. A blocking command could be a wait or a barrier. If at the end, there are receive IDs in the pattern instance, then the pattern instance is provably non-feasible. In such a case, the machine \emph{accepts} the program as free of deadlock on the pattern instance; otherwise, the machine \emph{rejects} the program as having a deadlock on the pattern instance.

\figref{fig:machineexample} is an example of the machine reduction given the CTP in \figref{fig:deadlock2}. The reduction applies the \emph{Sndi Command} in \figref{fig:machine} to consume the send $s_0$ on process $\thread_0$. The reduction shows that $s_0$ is removed from the $ctp$ in the state. Also, the count of issued sends is incremented by one on the keys $(1\ 0)$ and $(1\ \ast)$, respectively.

\begin{figure*}[tb]
\centering
\scalebox{0.9}{
\mprset{flushleft}
\begin{mathpar}
  ((((\mathrm{s}\ s_0\ 0\ 1)\ (\mathrm{r}\ r_0\ \ast\ 0\ w_0)\ \ldots\ \bot)\ \thread_1\ \thread_2)\ (((mt\ [(1\ 0)\rightarrow 0])\ [(1\ \ast)\rightarrow 0])\ \ldots)\ \eprcv\ \epwait\ \epbarrier\ (\mathrm{r_0}\ \mathrm{r_2}\ \mathrm{r_3})) \reduce{m}
 ((((\mathrm{r}\ r_0\ \ast\ 0\ w_0)\ \ldots\ \bot)\ \thread_1\ \thread_2)\ (((mt\ [(1\ 0)\rightarrow 1])\ [(1\ \ast)\rightarrow 1])\ \ldots)\ \eprcv\ \epwait\ \epbarrier\ (\mathrm{r_0}\ \mathrm{r_2}\ \mathrm{r_3}))
\end{mathpar}
}
\caption{An example of machine reduction. }
\label{fig:machineexample}
\end{figure*}

The soundness for the abstract machine is given in \lemmaref{lemma:sound}.

\begin{lemma}
  The machine implementing \textrm{FEASIBLECHECK} is sound in that it
  only accepts programs that do not deadlock on the associated pattern
  instance (but it may reject some programs as having a deadlock on
  that instance when in fact they do not).
\label{lemma:sound}
\end{lemma}
\begin{proof}
The commands defined in \figref{fig:machineexample} must never claim to be able to consume a send, a receive, or a barrier incorrectly for the machine to be sound.

Some rules are trivial to prove. In precise, \emph{Send Command} and \emph{Receive Command} simply consume a non-blocking send or a non-blocking receive according to the semantics. The rules also update the associated counts \epsnd\ and \epwait\ with correct values. \emph{Wait (RCVI) Command 1} consumes a wait because there is no receives in $\epwait$ to be witnessed by the wait. \emph{Wait (RCVI) Command 2} suspends a wait because the next receive that the wait witnesses is in the pattern instance. The program that reaches all the receives in the pattern instance may have a deadlock and is rejected by the machine. \emph{Barrier Command 1} suspends a barrier because not all the barriers in the same group are witnessed. \emph{Barrier Command 2} consume a suspended barrier because all the barriers in the same group are witnessed.

  Only \emph{Wait (RCVI) Command 3} is non-trivial to prove. The rule uses two conditions 
  $\eprcv(v_{to0},v_{frm0}) < \epsnd(v_{to0},v_{frm0})$
and 
$\eprcv(v_{to0},\ast) < \epsnd(v_{to0},\ast)$
to check if the receive $\aid_0$ can be consumed. Note that the messages are received in a FIFO order on any process. If $\aid_0$ is a wildcard receive on the process $v_{to0}$, the two conditions are equivalent, both checking if there exists at least one send that can match $\aid_0$ after all the preceding wildcard receives on $v_{to0}$ are matched. 
If $\aid_0$ is a deterministic receive on the process $v_{to0}$, then the first condition checks if there is at least one send that can match $\aid_0$ and all the preceding deterministic receives with identical source and destination are matched. The second condition checks if all the preceding wildcard receives on $v_{to0}$ are matched so that the message FIFO order is preserved. Both cases imply that $\aid_0$ can be consumed correctly. Therefore, the soundness of the machine is proved.  
\end{proof}

\begin{cor}
  The machine implementing \textrm{FEASIBLECHECK} never miss counts the number of sends, receives matched and barriers: \eprcv, \epsnd\ and \epbarrier\ are correct.
\end{cor}
\label{cor:count}
\begin{proof}
  The \emph{Sndi Command} increments count every time the rule activates and updates both the counter for the specified endpoints and special counter that records sends that can match with wildcard receives. The \emph{Wait (Rcvi) Command 3} only increments the indicated receive counter when it is possible to consume the receive and by \lemmaref{lemma:sound}, the machine only matches in a way that is sound. The \emph{Barrier Command 1} only increments the indicated barrier counter when the barrier is witnessed. The counters are not incremented in any other rule. Therefore, nothing is missed, and nothing is double counted.
\end{proof}
\begin{cor}
  \algoref{algo:main} is sound and complete if and only if the function \textrm{PATTERNMATCH} is complete (i.e., it gives all pattern instances and possibly more) and the function \textrm{VALIDATE} is sound and complete (i.e., any deadlock it detects is a real one and no real deadlocks are rejected).
\end{cor}
  
The presentation further discusses the completeness of the function \textrm{PATTERNMATCH} and the soundness and completeness of the function \textrm{VALIDATE} for two distinct deadlock patterns, circular dependency and orphaned receive. 

\begin{comment}
%%Soundness Proof needs to be revised such that it shows the feasible check (operational semantics) is sound.
The completeness proof for the abstract machine in \figref{fig:machine} is given in \lemmaref{lemma:complete}.
This proof assumes that the function \textrm{PATTERNMATCH} detects all the instances for a particular pattern. This assumption is proved for the circular dependency pattern and the orphaned receive pattern latter sections. 

\begin{lemma}[Completeness for Feasible Check]
  The machine implementing \textrm{FEASIBLECHECK} is sound for a given pattern instance in that only a program with no deadlock on that instance is accepted; thus, it may reject some programs as having a deadlock on an instance when in fact they do not.
  
  The machine implementing \textrm{FEASIBLECHECK} is sound for a given pattern instance in that it may reject a program as having a deadlock on that instance when in fact it does not.
  
For any single-path MPI program, \textit{ctp}, any feasible schedule for a deadlock pattern instance is demonstrated by the function \textrm{FEASIBLECHECK} in \algoref{algo:main}. 
\label{lemma:complete}
\end{lemma}
\begin{proof}
Proof by showing that the abstract machine in \figref{fig:machine} simulates the message communication under infinite buffer semantics. For the \emph{Sndi Command} and \emph{Rcvi Command} rules, a send or receive is consumed immediately and two structures $\epsnd$ and $\epwait$, respectively, are updated. This is consistent with the issuing of send and receive under infinite buffer semantics. The three cases of \emph{Wait Command} witness the completion of the receives that are not in the pattern $\mathit{pt}$ and intend to get to the receives in $\mathit{pt}$. The two cases of \emph{Barrier Command} block the execution of a member process until all the barriers in the group are witnessed. Since the abstract machine in \figref{fig:machine} is able to simulate the behavior for infinite buffer semantics, any feasible schedule should be demonstrated by executing \textit{ctp} on the machine.
\end{proof}
\end{comment}
