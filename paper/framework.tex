\section{Main Framework}

%%The general algorithm including three steps: Pattern Match, Feasible Check and Validation. The pseudocode needs to be revised so it shows each step. 


\algoref{algo:main} describes the general structure of the approach in this paper which consists of three distinct steps: pattern matching (line 1), feasibility checking (line 3), and validating (line 6). $\mathrm{PATTERNMATCH}$ statically generates a set ($\mathit{PT}$) of matched pattern instances in the \emph{ctp} with the help of an additional input, $M$, that defines all the potential match-pairs in the program. $M$ can be generated in quadratic time \cite{DBLP:conf/kbse/HuangMM13}. 

$\mathrm{FEASIBLECHECK}$ is an abstract machine to prune pattern instances for which it is possible prove no feasible schedule exists. In other words, it is provably not possible to execute the \emph{ctp} such that each process associated with a receive ID in the pattern instance is at that receive. The machine removes matched receive IDs from the pattern instance as it executes the \emph{ctp}, so if $\mathit{pt^\prime}$ is not empty upon return, the pattern instance is provably not feasible and the algorithm continues with the next pattern instance (line 5). The algorithm additionally returns the number of issued sends ($\mathit{N_s}$) and the number of issued receives ($\mathit{N_r}$). These are used in validation depending on the type of the pattern instance: circular dependency or orphaned receive.

%The framework is useful for error detection with appropriate pattern match and validation algorithms. This paper applies the framework for deadlock detection based on two types of deadlock patterns in the next two sections.

\begin{algorithm}[t]
\caption{Main Framework}\label{algo:main}
\begin{algorithmic}[1]
%\Procedure{Main Entrance}{}
%\Require $\mathit{ctp}$, a single-path MPI program
%\Require $\mathit{M}(\mathtt{r_c}) = \{\mathtt{s_l}\mid(\mathtt{s_l},\mathtt{r_c})\in\mathit{M}\}$, a set of potentially matched sends for $\mathtt{r_c}$
%\State  $\mathit{PT}$, a set of pattern instances
%\State  $\mathit{pt}$, a set of receives in the pattern instance $\mathit{pt}\in\mathit{PT}$
\State  $\mathit{PT} \gets$ \Call {PatternMatch}{$\mathit{ctp}$, $\mathit{M}$}
\For{$\mathit{pt} \in \mathit{PT}$}
\State ($\mathit{N_s}, \mathit{N_r}, \mathit{pt^\prime})\gets$\Call {FeasibleCheck}{$\mathit{pt}$, $\mathit{ctp}$}
\If{$\mathit{pt^\prime} \neq \emptyset$}
\State continue.
\ElsIf{$\neg$\Call {Validate}{$\mathit{N_s}, \mathit{N_r}, \mathit{pt}$}}
\State continue.
\Else\ report error and exit.
\EndIf

%\State ($\mathit{ctp}_s, \mathit{N_s}, \mathit{N_r}, \mathit{empty}_{pt}) \gets$ \Call {ScheduleFinder}{$\mathit{pt}$}
%\If{$\mathit{empty}_{pt}$} 
%\If{\Call{isCircular}{$\mathit{pt}$}}
%\For{$\mathtt{r_c}\in\mathit{pt}$}
%\State $\mathit{src} \gets$ source endpoint of $\mathtt{r_c}$, $\mathit{dest} \gets$ destination endpoint of $\mathtt{r_c}$
%\If{$\mathit{N_s}(\mathit{dest},\mathit{src}) > \mathit{N_r}(\mathit{dest},\mathit{src})$}
%\State \textbf{continue} \textit{point}
%\EndIf
%\EndFor
%\State report deadlock and exit.
%\EndIf
%\If{\Call {isMismatch}{$\mathit{pt}} \in$}
%\If{\textproc{SAT}({\Call {Encode}{$\mathit{ctp}_s$}})}
%\State report deadlock and exit.
%\EndIf
%\EndIf
%\EndIf
\EndFor
%\EndProcedure
\end{algorithmic}
\end{algorithm}

%%The feasible check and the soundness proof of feasible check (assuming pattern match is sound and validation is sound and complete)

$\mathrm{VALIDATE}$ proves a pattern instance feasible, which means that it is a real deadlock in the \emph{ctp}. If the deadlock is real, the algorithm reports the error and exits (line 8); otherwise it continues with the next pattern instance.
\textrm{FEASIBLECHECK} is able to efficiently prune schedules that are provably non-feasible with predictive analysis using counting and an auxiliary data structures to track FIFO ordering on messages. 

\figref{fig:machine} is a term rewriting system for a syntactic
machine (i.e., the machine state is represented by a string) for
$\mathrm{FEASIBLECHECK}$ to prove that a pattern instance is not
feasible. \figref{fig:expr:stx}(b) is the syntax for that machine. The
rewrites define how the machine executes an input \emph{ctp} and
pattern instance \emph{pt} by evolving the machine state. At a high-level, the machine
\begin{compactitem}
\item Process a send, receive, or barrier by counting the send (\emph{Sndi Command}), queuing up the receive on the indicated wait ID (\emph{Rcvi Command}), or counting the barrier (\emph{Barrier Command 1}).
\item Consume a waits when the associated queue is empty (\emph{Wait (Rcvi) Command 1})
\item Remove a receive ID from the pattern instance when the associated receive is next on the queue for the indicated wait (\emph{Wait (Rcvi) Command 2}).
\item Remove the next receive from the queue for the indicated wait and update the number of receives when feasible (\emph{Wait (Rcvi) Command 3}).
\item Consume a barrier if all the processes have arrived (\emph{Barrier Command 2})---communicator groups may only be used once.
\end{compactitem}
At a lower-level, the machine state (\textit{st}) is a six-tuple of variables. The first variable \textit{ctp} defines the concurrent trace program being analyzed. The set \epsnd\ maps a destination endpoint and a source endpoint to a number that is used to count issued sends. The variable \eprcv\ has the same structure only the number is used to count the number of matched receives. The variable \epwait\ records the pending receives by mapping the unique identifier of a wait to a set of the issued receives $\mathit{rcv}$. 
%A nearest-enclosing wait is the first wait that witnesses the completion of a receive by indicating that the message is delivered and that all the previous receives on the same process issued earlier are complete as well. 
In this set, the action identifier, the source endpoint and the destination endpoint are recorded for each receive. The variable \epbarrier\ maps the unique identifier of a communicator to a number that is used to count the number of witnessed barriers.

\begin{figure*}[tb]
\centering
\scalebox{0.9}{
\mprset{flushleft}
\begin{mathpar}

\inferrule[Sndi Command]{
  \epsnd(v_{to},v_{frm}) = v_c \\ \epsnd^\prime = \epsnd[(v_{to},v_{frm}) \mapsto v_c +1] \\ 
  %\epsnd^{\prime\prime} = \epsnd^\prime[\forall v\ldotp \epsnd(v_{to},v) = v_i \mid (v_{to},v) \mapsto v_i +1] 
 \epsnd(v_{to},\ast) = v_i \\ \epsnd^{\prime\prime} = \epsnd^\prime[(v_{to},\ast) \mapsto v_i +1] 
}{
  ((\thread_0\ \ldots\ ((\sendi\ \aid\ v_{frm}\ v_{to})\ \cmd_1\ \ldots\ \bot)\ \thread_2\ \ldots)\ \epsnd\ \eprcv\ \epwait\ \epbarrier\ \rcvp) \reduce{m}
  ((\thread_0\ \ldots\ (\cmd_1\ \ldots\ \bot)\ \thread_2\ \ldots)\ \epsnd^{\prime\prime}\ \eprcv\ \epwait\ \epbarrier\ \rcvp)
}

\and

\inferrule[Rcvi Command]{
 \epwait(\aid_w) =  ([\aid_1\ v_{frm1}\ v_{to1}]\ \ldots)
 \\ \epwait^\prime = \epwait [ \aid_w \mapsto ([\aid_0\ v_{frm0}\ v_{to0}]\ [\aid_1\ v_{frm1}\ v_{to1}]\ \ldots])] 
}{
  ((\thread_0\ \ldots\ ((\recvi\ \aid_0\ v_{frm0}\ v_{to0}\ \aid_w)\ \cmd_1\ \ldots\ \bot)\ \thread_2\ \ldots)\ \epsnd\ \eprcv\ \epwait\ \epbarrier\ \rcvp) \reduce{m}
  ((\thread_0\ \ldots\ (\cmd_1\ \ldots\ \bot)\ \thread_2\ \ldots)\ \epsnd\ \eprcv\ \epwait^\prime\ \epbarrier\ \rcvp)
}
\and
\inferrule[Wait (rcvi) Command 1]
{
  \epwait(\aid_w) = ()
}{
  ((\thread_0\ \ldots\ ((\wait\ \aid_w)\ \cmd_1\ \ldots\ \bot)\ \thread_2\ \ldots)\ \epsnd\ \eprcv\ \epwait\ \epbarrier\ \rcvp) \reduce{m}
  ((\thread_0\ \ldots\ (\cmd_1\ \ldots\ \bot)\ \thread_2\ \ldots)\ \epsnd\ \eprcv\ \epwait\ \epbarrier\ \rcvp)
}
\and
\inferrule[Wait (rcvi) Command 2]
{
   \epwait(\aid_w) = ([\aid_0\ v_{frm0}\ v_{to0}]\ [\aid_1\ v_{frm1}\ v_{to1}]\ \ldots) \\ \rcvp = (\aid_a\ \ldots\ \aid_0\ \aid_b\ \ldots) \\ \aid_0 \in \rcvp \\ \rcvp^\prime = (\aid_a\ \ldots\ \aid_b\ \ldots)
}{
  ((\thread_0\ \ldots\ ((\wait\ \aid_w)\ \cmd_1\ \ldots\ \bot)\ \thread_2\ \ldots)\ \epsnd\ \eprcv\ \epwait\ \epbarrier\ \rcvp) \reduce{m}
  ((\thread_0\ \ldots\ ((\wait\ \aid_w)\ \cmd_1\ \ldots\ \bot)\ \thread_2\ \ldots)\ \epsnd\ \eprcv\ \epwait\ \epbarrier\ \rcvp^\prime)
}
\and
\inferrule[Wait (rcvi) Command 3]
{
  \epwait(\aid_w) = ([\aid_0\ v_{frm0}\ v_{to0}]\ [\aid_1\ v_{frm1}\ v_{to1}]\ \ldots) \\
  \aid_0 \notin \rcvp \\ \eprcv(v_{to0},v_{frm0}) < \epsnd(v_{to0},v_{frm0}) \\ \eprcv(v_{to0},\ast) < \epsnd(v_{to0},\ast) \\
   \eprcv(v_{to0},v_{frm0}) = v_c \\
    \eprcv^\prime = \eprcv [(v_{to0}, v_{frm0}) \mapsto v_c + 1]] \\ 
    \epwait^\prime = \epwait [\aid_w\ \mapsto\ ([\aid_1\ v_{frm1}\ v_{to1}]\ \ldots)]
}{
  ((\thread_0\ \ldots\ ((\wait\ \aid_w)\ \cmd_1\ \ldots\ \bot)\ \thread_2\ \ldots)\ \epsnd\ \eprcv\ \epwait\ \epbarrier\ \rcvp) \reduce{m}
  ((\thread_0\ \ldots\ ((\wait\ \aid_w)\ \cmd_1\ \ldots\ \bot)\ \thread_2\ \ldots)\ \epsnd\ \eprcv^\prime\ \epwait^\prime\ \epbarrier\ \rcvp)
}
\and
\inferrule[Barrier Command 1]
{
  \epbarrier(\aid_0) = v_c \\ v_c < N_{proc} \\ \epbarrier^\prime = \epbarrier[\aid_0 \mapsto  v_c + 1]
}{
 ((\thread_0\ \ldots\ ((\barrier\ \aid_0)\ \cmd_1\ \ldots\ \bot)\ \thread_2\ \ldots)\ \epsnd\ \eprcv\ \epwait\ \epbarrier\ \rcvp) \reduce{m}
 ((\thread_0\ \ldots\ ((\barrier\ \aid_0)\ \cmd_1\ \ldots\ \bot)\ \thread_2\ \ldots)\ \epsnd\ \eprcv\ \epwait\ \epbarrier^\prime\ \rcvp)
}
\and
\inferrule[Barrier Command 2]
{
  \epbarrier(\aid_0) = N_{proc}
}{
 ((\thread_0\ \ldots\ ((\barrier\ \aid_0)\ \cmd_1\ \ldots\ \bot)\ \thread_2\ \ldots)\ \epsnd\ \eprcv\ \epwait\ \epbarrier\ \rcvp) \reduce{m}
 ((\thread_0\ \ldots\ (\cmd_1\ \ldots\ \bot)\ \thread_2\ \ldots)\ \epsnd\ \eprcv\ \epwait\ \epbarrier\ \rcvp)
}

\end{mathpar}}
\caption{Machine Reductions ($\reduce{m}$). }
\label{fig:machine}
\end{figure*}

The \emph{Sndi Command} in \figref{fig:machine} consumes sends. 
$\epsnd^\prime$\ is a new set, just like the old set $\epsnd$, only the new set maps the destination
endpoint $v_{to}$\ and the source endpoint $v_{frm}$ to the number $v_c + 1$ where $v_c$ is the content in the old set.
The set is also updated such that it maps $v_{to}$\ and $\ast$ to the number $v_i + 1$ where $v_i$ is the content in the old set. Note that the notation $\ast$ is a special source endpoint indicating any source.

The \emph{Rcvi Command} in \figref{fig:machine} consumes receives by updating the set \epwait. 
Similar to the rule \emph{Sndi Command}, \epwait\ merely adds a new record for the receive $x_0$ that is indexed by the 
wait that witnesses the completion of $x_0$.

The \emph{Wait (Rcvi) Command} operates in three ways. 
If the wait $\aid_w$ maps to an empty set in \epwait, indicating that no receives need to be completed by $\aid_w$, then $\aid_w$ is simply consumed. 
If the first receive $\aid_0$ in $\epwait(\aid_w)$ is stored in \rcvp\ where the notation $\in$ is used to indicate this condition, then $\aid_0$ is removed from \rcvp\ meaning that $\aid_0$ in \rcvp\ is reached. 
The last rule for wait checks whether the first receive $\aid_0$\ in $\epwait(x_w)$ is able to be consumed. The rule is only active if $\aid_0$ is not in \rcvp. The rule requires that there are more counted sends than counted receives with common source and destination endpoints and that there are more counted sends than counted receives for any preceding wildcard receives. The condition indicate that at least one send can be matched with $\aid_0$. If this condition holds, then the set \eprcv\ is updated with the counted receive and $\aid_0$ is then removed from \epwait. 

The \emph{Barrier Command} moves the barrier forward by its synchronization rule. It is assumed that the group of any barrier consists of all the processes in $\mathit{ctp}$. 
If the count of the witnessed barriers $\epbarrier(\aid_0)$ for a specific communicator $\aid_0$ is less than the total number of the processes $N_{proc}$ indicating that the barriers for $\aid_0$ are not matched, then the barrier is not consumed and $\epbarrier(\aid_0)$ is incremented. The barrier can only be consumed when the count $\epbarrier(\aid_0)$ is equal to $N_{proc}$.

The machine rewrites the state until no more reduction rules can be applied indicating that there is no way to further execute the program. The first statement that cannot be consumed on any process is either the bottom of the process or a blocking command. A blocking command could be a wait or a barrier. If at the end, there are receive IDs in the pattern instance, then the pattern instance is provably non-feasible. In such a case, the machine \emph{accepts} the program as free of deadlock on the pattern instance; otherwise, the machine \emph{rejects} the program as having a deadlock on the pattern instance.

\begin{lemma}
  The machine implementing \textrm{FEASIBLECHECK} is sound in that it
  only accepts programs that do not deadlock on the associated pattern
  instance (but it may reject some programs as having a deadlock on
  that instance when in fact they do not).
\label{lemma:sound}
\end{lemma}
\begin{proof}
  Only \emph{Wait (RCVI) Command 3} is discussed since the
  other rules are simple (and trivial to prove). \emph{Wait (RCVI) Command 3} must never
  claim to not be able to consume a receive command incorrectly for
  the machine to be sound.
\end{proof}

\begin{cor}
  The machine implementing \textrm{FEASIBLECHECK} never miss counts the number of send and receives matched: \eprcv\ and \epsnd\ are correct.
\end{cor}
\begin{proof}
  \emph{Sndi Command} increments count every time the rule activates and updates both the counter for the specified endpoints and special counter that records sends that can match with wildcard receives. The \emph{Wait (Rcvi) Command 3} rule only increments the indicated receive counter when it is possible to consume the receive and by \lemmaref{lemma:sound}, the machine only matches in a way that is sound. The counters are not incremented in any other rule. Therefore, nothing is missed, and nothing is double counted.
\end{proof}
\begin{cor}
  \algoref{algo:main} is sound and complete if and only if \textrm{PATTERNMATCH} is complete (i.e., it gives all pattern instances and possibly more) and validate is sound and complete.
\end{cor}


\begin{comment}
%%Soundness Proof needs to be revised such that it shows the feasible check (operational semantics) is sound.
The completeness proof for the abstract machine in \figref{fig:machine} is given in \lemmaref{lemma:complete}.
This proof assumes that the function \textrm{PATTERNMATCH} detects all the instances for a particular pattern. This assumption is proved for the circular dependency pattern and the orphaned receive pattern latter sections. 

\begin{lemma}[Completeness for Feasible Check]
  The machine implementing \textrm{FEASIBLECHECK} is sound for a given pattern instance in that only a program with no deadlock on that instance is accepted; thus, it may reject some programs as having a deadlock on an instance when in fact they do not.
  
  The machine implementing \textrm{FEASIBLECHECK} is sound for a given pattern instance in that it may reject a program as having a deadlock on that instance when in fact it does not.
  
For any single-path MPI program, \textit{ctp}, any feasible schedule for a deadlock pattern instance is demonstrated by the function \textrm{FEASIBLECHECK} in \algoref{algo:main}. 
\label{lemma:complete}
\end{lemma}
\begin{proof}
Proof by showing that the abstract machine in \figref{fig:machine} simulates the message communication under infinite buffer semantics. For the \emph{Sndi Command} and \emph{Rcvi Command} rules, a send or receive is consumed immediately and two structures $\epsnd$ and $\epwait$, respectively, are updated. This is consistent with the issuing of send and receive under infinite buffer semantics. The three cases of \emph{Wait Command} witness the completion of the receives that are not in the pattern $\mathit{pt}$ and intend to get to the receives in $\mathit{pt}$. The two cases of \emph{Barrier Command} block the execution of a member process until all the barriers in the group are witnessed. Since the abstract machine in \figref{fig:machine} is able to simulate the behavior for infinite buffer semantics, any feasible schedule should be demonstrated by executing \textit{ctp} on the machine.
\end{proof}
\end{comment}
