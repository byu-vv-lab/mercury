Message passing is the common way for processes to communicate and synchronize in high performance computing applications. Of concern in
any message passing program is deadlock, and determining whether or not a single-path program deadlocks is an NP--complete problem. This paper
presents a technique for detecting deadlocks in single-path message passing programs by three steps: matching patterns for common forms of deadlock, leveraging a low-cost static analyzer to pruning infeasible pattern instances from a set of potential deadlocks, and validating if the feasible pattern instances imply real deadlocks in program executions. 
The novelty of the approach is not in exhaustively searching all possible resolutions of send-receive matches in feasible check which takes exponential time complexity, but in simply counting and comparing the number of issued sends and receives which is in quadratic cost and does not lose any feasible pattern instances.  
Also, the paper presents two common deadlock patterns: circular dependency and orphaned receive, and how they can be used to apply the technique in the paper to detect deadlocks with different strategies of pattern matching and validation. 
For circular dependency pattern, the strategy uses simple rules for validation. For orphaned receive pattern, the validation uses a high-cost SMT encoding to identify real deadlock. The paper additionally gives proofs that the approach is sound and complete for each deadlock pattern and compares the approach with two other deadlock verifiers on a set of benchmarks where the new approach completes the analysis while the other approaches time out. The comparison shows that the new approach is able to respond in milliseconds even when the program contains hundreds of operations and over $10^{257}$ match possibilities for those operations.
