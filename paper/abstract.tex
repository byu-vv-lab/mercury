The deadlock problem for any single-path message passing program (a program without any branches and loops) is NP--complete. This paper presents a technique for detecting deadlocks in single-path message passing programs by three steps: matching patterns for common forms of deadlock, leveraging a low-cost static analyzer to pruning infeasible instances from a set of potential deadlocks, and validating feasible instances imply real deadlocks.
The novelty of the approach is not in exhaustively searching all possible resolutions of send-receive matches in feasible check, but in simply counting and comparing the number of issued sends and receives which is in quadratic cost and does not lose any feasible instances. The paper further presents two common deadlock patterns: circular dependency and orphaned receive, and how to apply the technique above to detect deadlocks for these two patterns. 
The circular dependency uses simple rules for validation. The orphaned receive requires a high-cost SMT encoding to validate real deadlocks. 
The paper proves the approach is sound and complete for each pattern and compares the approach with two other verifiers on typical benchmarks where the new approach completes the analysis while the others time-out. The comparison shows that the new approach is able to respond in milliseconds even when the program contains over $10^{257}$ possibilities for message communication.
