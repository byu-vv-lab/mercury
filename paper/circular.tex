\section{Circular Dependency}

%%%% This section presents the pattern match algorithm and validation for circular dependency.


A deadlock may occur when there exists a circular dependency in messages. This circular dependency is defined in \defref{def:circular} that depends on the sequential relation defined in \defref{def:seqrelation}.

\begin{definition}
A sequential relation for a process, $p$, is a three-tuple $(p, \mathit{r_c}, \mathit{s_l})$, where the receive $\mathit{r_c}$ and the wait $\mathit{w_d}$ that witnesses the completion of $\mathit{r_c}$ are both followed by the send $\mathit{s_l}$ on $p$. 
\label{def:seqrelation}
\end{definition}

\begin{definition}
Given a set of sequential relations, $D$, a circular dependency $\tau$ $=$ $\langle(p_0, \mathit{r}_0, \mathit{s}_0),$ $\ldots,$ $(p_m, \mathit{r}_m, \mathit{s}_m)\rangle$ is a sequence in $D$, such that the following properties hold.
\begin{compactenum}
\item at least two sequential relations exist in $\tau$;
\item for all distinct $i,j \in [0,m]$, $p_i \neq p_j$;
\item for all $i \in [0,m], j = (i+1) \% m$, $\mathit{s}_i$ can potentially match $\mathit{r}_j$;
%\item for all $i \in [1,m]$, if $\mathtt{r}_i$ is a deterministic receive, then there are no wildcard receives preceding $\mathtt{r}_i$ on $p_i$.
\end{compactenum}
\label{def:circular}
\end{definition}

In \figref{fig:deadlock2}, the CTP has a circular dependency in messages $\langle(p_0, \mathit{r_{0}}, \mathit{s_{1}}),$ $(p_1, \mathit{r_{2}}, \mathit{s_{2}}),$ $(p_2, \mathit{r_{3}}, \mathit{s_{3}})\rangle$. Each receive in the circular dependency waits for the issuing of a send from one of the other processes but never gets a response. For instance, $\mathit{r_{0}}$ can never match $\mathit{s_{3}}$ because of the dependency. For simplicity, a instance of the circular dependency pattern only records the receives in a set. For example, $(\mathit{r_{0}}, \mathit{r_{2}}, \mathit{r_{3}})$ is a instance of the circular dependency pattern for the CTP in \figref{fig:deadlock2}. 

\subsection{Pattern Match for Circular Dependency}

\begin{algorithm}
\caption{Finding Circular Dependency}\label{algo:circular}
\begin{algorithmic}[1]
%\Require $\mathit{ctp}$, a single-path MPI program
%\Require $\mathit{M}(\mathtt{r_c}) = \{\mathtt{s_l}\mid(\mathtt{s_l},\mathtt{r_c})\in\mathit{M}\}$, a set of potentially matched sends for $\mathtt{r_c}$
\State $\mathit{PT} \gets \emptyset$
\State $\mathit{E} \gets \emptyset$, $\mathit{V} \gets \emptyset$
%a relation from an operation $\mathit{e}$ to another operation $\mathit{e}$
%a set of operations
\State $\mathit{R} \gets \emptyset$, $\mathit{R_w} \gets \emptyset$
%\State $\mathit{PT}$, a set of circular dependency pattern instances
%\State $\mathit{R}(p) = \{\mathtt{r_c}\mid(p,\mathtt{r_c})\in\mathit{R}\}$, the witnessed receives on process $p$
%\State $\mathit{R_w}(p) = \{\mathtt{r_c}\mid(p,\mathtt{r_c})\in\mathit{R_w}\}$, the receives for the last witnessed wait on process $p$ 
\For{$(e_1, e_2, \dots, e_n) \in \mathit{ctp}$}
\For{$i \gets 1$ to $n$}
\If{$\mathit{e_i}$ is a receive}
%\If{$\mathit{isIssued}$ and $\mathtt{e}$ is a deterministic receive}
%\State \textbf{break}
%\EndIf
%\If{$\mathtt{e}$ is a wildcard receive}
%\State $\mathit{isIssued} \gets true$
%\EndIf
\State $\mathit{R} = \mathit{R} \cup \{\mathit{e_i}\}$
\State $\mathit{V} = \mathit{V} \cup \{\mathit{e_i}\}$
\For{$\mathit{s_l} \in \mathit{M}(\mathit{e_i})$} \Comment{add match relation to $\mathit{E}$}
\State $\mathit{E} = \mathit{E} \cup \{(\mathit{e_i},\mathit{s_l})\}$  
\EndFor
\EndIf
\If{$\mathit{e_i}$ is a wait}
\For{$\mathit{r_c} \in \mathit{R}$}
\State $\mathit{R_w} = \mathit{R_w} \cup \{\mathit{r_c}\}$
\EndFor
\State $\mathit{R} \gets \emptyset$ 
\EndIf
\If{$\mathit{e_i}$ is a send}
\State $\mathit{V} = \mathit{V} \cup \{\mathit{e_i}\}$
\For{$\mathit{r_c} \in \mathit{R_w}$}  \Comment{add HB relation from $\mathit{r_c}$ to $\mathit{e_i}$ to $\mathit{E}$}
\State $\mathit{E} = \mathit{E} \cup \{(\mathit{r_c},\mathit{e_i})\}$
\EndFor
\EndIf
\EndFor
\State $\mathit{R} \gets \emptyset$, $\mathit{R_w} \gets \emptyset$
\EndFor
\State $\mathit{PT} \gets$ \Call {Johnson}{$\mathit{V}$, $\mathit{E}$}
\end{algorithmic}
\end{algorithm}

\algoref{algo:circular} shows the steps for finding all the instances of the circular dependency pattern in $\mathit{ctp}$. In general, the algorithm is part of the function $\mathrm{PATTERNMATCH}$ in \algoref{algo:main}. It builds a graph by transforming the operations in $\mathit{ctp}$ to the vertices $\mathit{V}$ and transforming two types of relations to the edges $\mathit{E}$ and then finding all the cycles in the graph based on the Johnson's algorithm \cite{DBLP:journals/siamcomp/Johnson75}.
 
The variable $\mathit{V}$ is a set of operations. The variable $\mathit{E}$ is a set of edges each representing a relation from one operation to another. 
The set $\mathit{PT}$ stores the matched pattern instances.
The set $\mathit{R}$ stores the witnessed receives on the process $p$ that is a list of operations $(e_1, e_2, \dots, e_n)$. 
The set $\mathit{R_w}$ stores the receives that are recently witnessed on $p$.
%Each process $p$ in $\mathit{ctp}$ is a list of operations $(e_1, e_2, \dots, e_n)$. 

The algorithm checks each operation $e_i$ in $p$. 
If $\mathit{e_i}$ is a receive, then it is inserted into $\mathit{R}$ and $\mathit{V}$, respectively. Also, for each potentially matched send $\mathit{s_l}$ in $\mathit{M}(\mathit{e_i})$, the pair $(\mathit{e},\mathit{s_l})$ is inserted into $\mathit{E}$ indicating that a match relation from $\mathit{s_l}$ to $\mathit{e_i}$ is an edge in the graph. If $\mathit{e_i}$ is a wait, all the receives in $\mathit{R}$ are inserted to $\mathit{R_w}$ and $\mathit{R}$ is set back to an empty set, indicating that all the receives in $\mathit{R}$ are witnessed by $\mathit{e_i}$. \defref{def:seqrelation} requires for each sequential relation a receive and the wait that witnesses the completion of this receive both precede a send on an identical process. Therefore, %only the receives in the set $\mathit{Wset}$ are considered to build the happens-before relation. 
if $\mathit{e_i}$ is a send, the pair $(\mathit{r_c},\mathit{e_i})$ is inserted into $\mathit{E}$ at line 22 indicating that a happens-before relation from each witnessed receive $\mathit{r_c}\in\mathit{R_w}$ to $\mathit{e_i}$ is an edge in the graph. 

Finally, the function $\mathrm{JOHNSON}$ implements the Johnson's algorithm to compute all the cycles in the graph. Since an edge in any computed cycle is either a receive-send HB relation on an identical process, or a send-receive match relation across two processes, there exists exactly one sequential relation for any process in the cycle. Therefore, each cycle computed by the function $\mathrm{JOHNSON}$ is a instance of the circular dependency pattern. As discussed earlier, only receives in each cycle are stored to represent a instance in the set $\mathit{PT}$. The complexity of program traversal is $O(\mathrm{N}^2)$, where $\mathrm{N}$ is the total number of operations in the program. The complexity of Johnson's algorithm is $O((\mathrm{v}+\mathrm{e})(\mathrm{c}+1))$ $\approx$ $O((\mathrm{c}+1)\mathrm{N}^2)$, where $\mathrm{v}$ is the number of vertices, $\mathrm{e}$ is the number of edges, and $\mathrm{c}$ is the number of cycles. Therefore, the total complexity of the algorithm is $O((\mathrm{c}+1)\mathrm{N}^2)$.

\subsection{Validation for Circular Dependency}

%%revise the following algorithm of validating circular dependency pattern
\examplefigfour


If the function \textrm{FEASIBLECHECK} demonstrates that a potentially feasible schedule exists, \algoref{algo:vcircular} further validates whether or not a real deadlock exists for the pattern instance \textit{pt}. The condition at line 4 checks if there exists a send that may match any receive $\mathit{r_c}$ in \textit{pt} by comparing the count of issued sends and the count of issued receives.    
The function $\mathit{N_s}(\mathit{dest},\mathit{src})$ returns the count of issued sends with the destination $\mathit{dest}$ and the source $\mathit{src}$. The function $\mathit{N_r}(\mathit{dest},\mathit{src})$ returns the count of issued receives with the destination $\mathit{dest}$ and the source $\mathit{src}$.
If the condition is true, no real deadlock exists for \textit{pt} because $\mathit{r_c}$ can be matched and the cycle in \textit{pt} does not hold. If this condition is not satisfiable for any receive in \textit{pt}, the algorithm detects a real deadlock for \textit{pt}.
As an example, \algoref{algo:vcircular} reports that the CTP in \figref{fig:nodeadlock2} has no real deadlock for the instance of the circular dependency pattern $(r_0,r_1,r_2)$ because the send $s_0$ matches the receive $r_1$ and the cycle does not hold.

\begin{algorithm}
\caption{Validate Circular Dependency}\label{algo:vcircular}
\begin{algorithmic}[1]
%\Require $\mathit{ctp}$, a single-path MPI program
%\Require $\mathit{M}(\mathtt{r_c}) = \{\mathtt{s_l}\mid(\mathtt{s_l},\mathtt{r_c})\in\mathit{M}\}$, a set of potentially matched sends for $\mathtt{r_c}$
%\State  $\mathit{PT}$, a set of pattern instances
%\State  $\mathit{pt}$, a set of receives in the pattern instance $\mathit{pt}\in\mathit{PT}$
%\State $\mathit{N_s}$, a set of numbers each representing the the number of issued sends given a destination and a source
%\State $\mathit{N_r}$, a set of numbers each representing the number of issued receives given a destination and a source
%\State ($\mathit{ctp}_s, \mathit{N_s}, \mathit{N_r}, \mathit{empty}_{pt}) \gets$ \Call {ScheduleFinder}{$\mathit{pt}$}
%\If{$\mathit{empty}_{pt}$} 
%\If{\Call{isCircular}{$\mathit{pt}$}}
\For{$\mathit{r_c}\in\mathit{pt}$}
\State $\mathit{src} \gets$ source endpoint of $\mathit{r_c}$ 
\State $\mathit{dest} \gets$ destination endpoint of $\mathit{r_c}$
\If{$\mathit{N_s}(\mathit{dest},\mathit{src}) > \mathit{N_r}(\mathit{dest},\mathit{src})$}
\State report no deadlock and exit.
\EndIf
\EndFor
\State report deadlock.
%\State report deadlock and exit.
%\EndIf
%\If{\Call {isMismatch}{$\mathit{pt}} \in$}
%\If{\textproc{SAT}({\Call {Encode}{$\mathit{ctp}_s$}})}
%\State report deadlock and exit.
%\EndIf
%\EndIf
%\EndIf
%\EndProcedure
\end{algorithmic}
\end{algorithm}


%%Soundness proof for pattern match needs to be added. the following proof needs to be revised to show that the validation is sound and complete.

The soundness proof for the validation in \algoref{algo:vcircular} is given in \lemmaref{lemma:circular}.

\begin{lemma}[Soundness for Circular Dependency]
For any single-path MPI program, \textit{ctp}, the detection of a deadlock by \algoref{algo:vcircular} for an instance of the circular dependency pattern, $\mathit{pt}$, indicates a real deadlock. 
\label{lemma:circular}
\end{lemma}
\begin{proof}
Proof by showing the existence of a deadlock. Since \algoref{algo:vcircular} detects a deadlock for $\mathit{pt}$, the condition at line 4 is not satisfied for any receive $r_c$ in $\mathit{pt}$ indicating that no send in the potentially feasible schedule can match $r_c$. Also, this schedule is executable in the machine in \figref{fig:machine}. Thus, a feasible schedule exists such that all the receives in $\mathit{pt}$ are reached that indicates a real deadlock. 
\end{proof} 

%%zero buffer for circular dependency

\subsection{Zero Buffer Semantics for Circular Dependency}
The deadlock patterns discussed above may also cause a program to deadlock under zero buffer semantics. Notice that the commands in \figref{fig:machine} are consistent with how messages communicate under infinite buffer semantics (e.g., a send is consumed immediately). The zero buffer semantics, however, enforce a different way of message communication. As such, a feasible infinite buffer schedule generated by \algoref{algo:main} is not able to witness a deadlock under zero buffer semantics. Therefore, the zero buffer compatibility should be checked for each generated schedule. \algoref{algo:main} is extended with two changes: 1) the zero buffer encoding rules (refer to \cite{HuangNFM15}) are added to the function $\mathrm{ENCODE}$; 2) The circular dependency pattern also needs an SMT encoding to check the feasibility of a schedule. As a note, to encode the match pairs for the circular dependency pattern only needs to ensure that each receive in the schedule is matched with some send. Once the schedule is proved to be zero buffer compatible, the program may deadlock under zero buffer semantics; otherwise, the pattern instance does not imply a real deadlock. 


