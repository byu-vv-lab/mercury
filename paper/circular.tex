\section{Circular Dependency}

\examplefigfour

A deadlock may occur when there exists a circular dependency in messages. This circular dependency is defined in \defref{def:circular} that depends on the sequential relation defined in \defref{def:seqrelation}. 

\begin{definition}
A sequential relation for a process, $p$, is a three-tuple $(p, \mathit{r_c}, \mathit{s_l})$, where the receive $\mathit{r_c}$ and the wait $\mathit{w_d}$ that witnesses the completion of $\mathit{r_c}$ are both followed by the send $\mathit{s_l}$ on $p$. 
\label{def:seqrelation}
\end{definition}

\begin{definition}
Given a set of sequential relations, $D$, a circular dependency $\tau$ $=$ $\langle(p_0, \mathit{r}_0, \mathit{s}_0),$ $\ldots,$ $(p_m, \mathit{r}_m, \mathit{s}_m)\rangle$ is a sequence in $D$, such that the following properties hold.
\begin{compactenum}
\item at least two sequential relations exist in $\tau$;
\item for all distinct $i,j \in [0,m]$, $p_i \neq p_j$;
\item for all $i \in [0,m], j = (i+1) \% m$, $\mathit{s}_i$ can potentially match $\mathit{r}_j$;
%\item for all $i \in [1,m]$, if $\mathtt{r}_i$ is a deterministic receive, then there are no wildcard receives preceding $\mathtt{r}_i$ on $p_i$.
\end{compactenum}
\label{def:circular}
\end{definition}

In \figref{fig:deadlock2}, the CTP has a circular dependency in messages $\langle(p_0, \mathit{r_{0}}, \mathit{s_{1}}),$ $(p_1, \mathit{r_{2}}, \mathit{s_{2}}),$ $(p_2, \mathit{r_{3}}, \mathit{s_{3}})\rangle$. Each receive in the circular dependency waits for the issuing of a send from one of the other processes but never gets a response. For instance, $\mathit{r_{0}}$ can never match $\mathit{s_{3}}$ because of the dependency. For simplicity, a instance of the circular dependency pattern only records the receives in a set. For example, $(\mathit{r_{0}}, \mathit{r_{2}}, \mathit{r_{3}})$ is a instance of the circular dependency pattern for the CTP in \figref{fig:deadlock2}. 

\subsection{Pattern Match for Circular Dependency}

\begin{algorithm}
\caption{Finding Circular Dependency}\label{algo:circular}
\begin{algorithmic}[1]
%\Require $\mathit{ctp}$, a single-path MPI program
%\Require $\mathit{M}(\mathtt{r_c}) = \{\mathtt{s_l}\mid(\mathtt{s_l},\mathtt{r_c})\in\mathit{M}\}$, a set of potentially matched sends for $\mathtt{r_c}$
\State $\mathit{PT} \gets \emptyset$
\State $\mathit{E} \gets \emptyset$, $\mathit{V} \gets \emptyset$
%a relation from an operation $\mathit{e}$ to another operation $\mathit{e}$
%a set of operations
\State $\mathit{R} \gets \emptyset$, $\mathit{R_w} \gets \emptyset$
%\State $\mathit{PT}$, a set of circular dependency pattern instances
%\State $\mathit{R}(p) = \{\mathtt{r_c}\mid(p,\mathtt{r_c})\in\mathit{R}\}$, the witnessed receives on process $p$
%\State $\mathit{R_w}(p) = \{\mathtt{r_c}\mid(p,\mathtt{r_c})\in\mathit{R_w}\}$, the receives for the last witnessed wait on process $p$ 
\For{$(e_1, e_2, \dots, e_n) \in \mathit{ctp}$}
\For{$i \gets 1$ to $n$}
\If{$\mathit{e_i}$ is a receive}
%\If{$\mathit{isIssued}$ and $\mathtt{e}$ is a deterministic receive}
%\State \textbf{break}
%\EndIf
%\If{$\mathtt{e}$ is a wildcard receive}
%\State $\mathit{isIssued} \gets true$
%\EndIf
\State $\mathit{R} = \mathit{R} \cup \{\mathit{e_i}\}$
\State $\mathit{V} = \mathit{V} \cup \{\mathit{e_i}\}$
\For{$\mathit{s_l} \in \mathit{M}(\mathit{e_i})$} \Comment{add match relation to $\mathit{E}$}
\State $\mathit{E} = \mathit{E} \cup \{(\mathit{e_i},\mathit{s_l})\}$  
\EndFor
\EndIf
\If{$\mathit{e_i}$ is a wait}
\For{$\mathit{r_c} \in \mathit{R}$}
\State $\mathit{R_w} = \mathit{R_w} \cup \{\mathit{r_c}\}$
\EndFor
\State $\mathit{R} \gets \emptyset$ 
\EndIf
\If{$\mathit{e_i}$ is a send}
\State $\mathit{V} = \mathit{V} \cup \{\mathit{e_i}\}$
\For{$\mathit{r_c} \in \mathit{R_w}$}  \Comment{add HB relation from $\mathit{r_c}$ to $\mathit{e_i}$ to $\mathit{E}$}
\State $\mathit{E} = \mathit{E} \cup \{(\mathit{r_c},\mathit{e_i})\}$
\EndFor
\EndIf
\EndFor
\State $\mathit{R} \gets \emptyset$, $\mathit{R_w} \gets \emptyset$
\EndFor
\State $\mathit{PT} \gets$ \Call {Johnson}{$\mathit{V}$, $\mathit{E}$}
\end{algorithmic}
\end{algorithm}

\algoref{algo:circular} shows the steps for finding all the instances of the circular dependency pattern in $\mathit{ctp}$. As a reminder, $M$ is the set of potential match-pairs in the \emph{ctp}.  In general, the algorithm is part of the function $\mathrm{PATTERNMATCH}$ in \algoref{algo:main}. It builds a graph by transforming the operations in $\mathit{ctp}$ to the vertices $\mathit{V}$ and transforming two types of relations to the edges $\mathit{E}$ and then finding all the cycles in the graph based on the Johnson's algorithm \cite{DBLP:journals/siamcomp/Johnson75}.
 
The variable $\mathit{V}$ is a set of operations. The variable $\mathit{E}$ is a set of edges each representing a relation from one operation to another. 
The set $\mathit{PT}$ stores the matched pattern instances.
The set $\mathit{R}$ stores the witnessed receives on the process $p$ that is a list of operations $(e_1, e_2, \dots, e_n)$. 
The set $\mathit{R_w}$ stores the receives that are recently witnessed on $p$.
%Each process $p$ in $\mathit{ctp}$ is a list of operations $(e_1, e_2, \dots, e_n)$. 

The function $\mathit{M}(\mathtt{r_c}) = \{\mathtt{s_l}\mid(\mathtt{s_l},\mathtt{r_c})\in\mathit{M}\}$ returns all potential sends for the receive $\mathtt{r_c}$. The algorithm checks each operation $e_i$ in $p$. 
If $\mathit{e_i}$ is a receive, then it is inserted into $\mathit{R}$ and $\mathit{V}$, respectively. Also, for each potentially matched send $\mathit{s_l}$ in $\mathit{M}(\mathit{e_i})$, the pair $(\mathit{e},\mathit{s_l})$ is inserted into $\mathit{E}$ indicating that a match relation from $\mathit{s_l}$ to $\mathit{e_i}$ is an edge in the graph. If $\mathit{e_i}$ is a wait, all the receives in $\mathit{R}$ are inserted to $\mathit{R_w}$ and $\mathit{R}$ is set back to an empty set, indicating that all the receives in $\mathit{R}$ are witnessed by $\mathit{e_i}$. \defref{def:seqrelation} requires for each sequential relation a receive and the wait that witnesses the completion of this receive both precede a send on an identical process. Therefore, %only the receives in the set $\mathit{Wset}$ are considered to build the happens-before relation. 
if $\mathit{e_i}$ is a send, the pair $(\mathit{r_c},\mathit{e_i})$ is inserted into $\mathit{E}$ at line 22 indicating that a happens-before relation from each witnessed receive $\mathit{r_c}\in\mathit{R_w}$ to $\mathit{e_i}$ is an edge in the graph. 

Finally, the function $\mathrm{JOHNSON}$ implements the Johnson's algorithm to compute all the cycles in the graph. Since an edge in any computed cycle is either a receive-send HB relation on an identical process, or a send-receive match relation across two processes, there exists exactly one sequential relation for any process in the cycle. Therefore, each cycle computed by the function $\mathrm{JOHNSON}$ is a instance of the circular dependency pattern. As discussed earlier, only receives in each cycle are stored to represent a instance in the set $\mathit{PT}$. The complexity of program traversal is $O(\mathrm{N}^2)$, where $\mathrm{N}$ is the total number of operations in the program. The complexity of Johnson's algorithm is $O((\mathrm{v}+\mathrm{e})(\mathrm{c}+1))$ $\approx$ $O((\mathrm{c}+1)\mathrm{N}^2)$, where $\mathrm{v}$ is the number of vertices, $\mathrm{e}$ is the number of edges, and $\mathrm{c}$ is the number of cycles. Therefore, the total complexity of the algorithm is $O((\mathrm{c}+1)\mathrm{N}^2)$.

The completeness for \algoref{algo:circular} is given in \lemmaref{lemma:pmcircular}. 

\begin{lemma}
\label{lemma:pmcircular}
The pattern match in \algoref{algo:circular} is complete indicating that all possible pattern instances are detected.
\end{lemma}
\begin{proof}
The graph built in \algoref{algo:circular} consists of all possible vertices and all possible edges because the algorithm statically traverses each process from the beginning to the end and adds an edge once the relation is detected. Also, the Johnson's algorithm is able to compute all the cycles in the graph. Therefore, all possible instances for the circular dependency pattern are detected. 
\end{proof}

\subsection{Validation for Circular Dependency}

%%revise the following algorithm of validating circular dependency pattern

If the function \textrm{FEASIBLECHECK} demonstrates that a potentially feasible schedule exists, \algoref{algo:vcircular} further validates whether or not a real deadlock exists for the pattern instance \textit{pt}. The condition at line 4 checks if there exists a send that may match any receive $\mathit{r_c}$ in \textit{pt} by comparing the count of issued sends and the count of issued receives.    
The function $\mathit{N_s}(\mathit{dest},\mathit{src})$ returns the count of issued sends with the destination $\mathit{dest}$ and the source $\mathit{src}$. The function $\mathit{N_r}(\mathit{dest},\mathit{src})$ returns the count of issued receives with the destination $\mathit{dest}$ and the source $\mathit{src}$.
If the condition is true, no real deadlock exists for \textit{pt} because $\mathit{r_c}$ can be matched and the cycle in \textit{pt} does not hold. If this condition is not satisfiable for any receive in \textit{pt}, the algorithm detects a real deadlock for \textit{pt}.
As an example, \algoref{algo:vcircular} reports that the CTP in \figref{fig:nodeadlock2} has no real deadlock for the instance of the circular dependency pattern $(r_0,r_1,r_2)$ because the send $s_0$ matches the receive $r_1$ and the cycle does not hold.

\begin{algorithm}
\caption{Validate Circular Dependency}\label{algo:vcircular}
\begin{algorithmic}[1]
%\Require $\mathit{ctp}$, a single-path MPI program
%\Require $\mathit{M}(\mathtt{r_c}) = \{\mathtt{s_l}\mid(\mathtt{s_l},\mathtt{r_c})\in\mathit{M}\}$, a set of potentially matched sends for $\mathtt{r_c}$
%\State  $\mathit{PT}$, a set of pattern instances
%\State  $\mathit{pt}$, a set of receives in the pattern instance $\mathit{pt}\in\mathit{PT}$
%\State $\mathit{N_s}$, a set of numbers each representing the the number of issued sends given a destination and a source
%\State $\mathit{N_r}$, a set of numbers each representing the number of issued receives given a destination and a source
%\State ($\mathit{ctp}_s, \mathit{N_s}, \mathit{N_r}, \mathit{empty}_{pt}) \gets$ \Call {ScheduleFinder}{$\mathit{pt}$}
%\If{$\mathit{empty}_{pt}$} 
%\If{\Call{isCircular}{$\mathit{pt}$}}
\For{$\mathit{r_c}\in\mathit{pt}$}
\State $\mathit{src} \gets$ source endpoint of $\mathit{r_c}$ 
\State $\mathit{dest} \gets$ destination endpoint of $\mathit{r_c}$
\If{$\mathit{N_s}(\mathit{dest},\mathit{src}) > \mathit{N_r}(\mathit{dest},\mathit{src})$}
\State report no deadlock and exit.
\EndIf
\EndFor
\State report deadlock.
%\State report deadlock and exit.
%\EndIf
%\If{\Call {isMismatch}{$\mathit{pt}} \in$}
%\If{\textproc{SAT}({\Call {Encode}{$\mathit{ctp}_s$}})}
%\State report deadlock and exit.
%\EndIf
%\EndIf
%\EndIf
%\EndProcedure
\end{algorithmic}
\end{algorithm}


%%Soundness proof for pattern match needs to be added. the following proof needs to be revised to show that the validation is sound and complete.

The soundness and completeness proof for the validation method in \algoref{algo:vcircular} is given in \lemmaref{lemma:circular}.

\begin{lemma}
The validation method implementing \algoref{algo:vcircular} for an instance of the circular dependency pattern, $\mathit{pt}$, is sound and complete indicating that any detected deadlock is a real deadlock and any instance rejected by \algoref{algo:vcircular} is a not a real deadlock. 
\label{lemma:circular}
\end{lemma}
\begin{proof}
Since the counts for \epsnd\ and \eprcv\ are correct (\coref{cor:count}), the condition at line 4 is able to correctly check if a instance is a real deadlock or not. If the condition does not hold for some $r_c$, then $r_c$ can be matched and the dependency in the cycle does not exist. Therefore, $\mathit{pt}$ is not a real deadlock. If the condition holds for all the receives in $\mathit{pt}$, then no receive in $\mathit{pt}$ can be matched. Therefore, a real deadlock may occur for $\mathit{pt}$.
\end{proof} 

%%zero buffer for circular dependency




