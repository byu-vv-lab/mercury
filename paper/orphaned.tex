\section{Orphaned Receive}

%% rename the pattern as orphaned receive. This section presents the pattern match algorithm and validation for orphaned receive.

\examplefigone

A deadlock may occur when the runtime matches a wildcard receive with the send needed by a deterministic receive. For instance, in \figref{fig:deadlock1}, a deadlock may occur if the receive $\mathit{r_{0}}$ is matched with the send $\mathit{s_{1}}$ and there is no way to match the receive $\mathit{r_{1}}$ with the send $\mathit{s_{2}}$. This CTP shows an instance of the orphaned receive pattern defined in \defref{def:mismatch}.

\begin{definition}
An orphaned receive pattern is a pair $(\mathit{r_w}, \mathit{r_c})$ where, 
\begin{compactenum}
\item $\mathit{r_w}$ is a wildcard receive and $\mathit{r_c}$ is a deterministic receive that follows $\mathit{r_w}$ on an identical process $\mathit{p}$;
\item at least two sends from different source endpoints other than $\mathit{p}$ may potentially match $\mathit{r_w}$; and
\item among these matched sends, at least one send matches $\mathit{r_c}$. 
\end{compactenum}
\label{def:mismatch}
\end{definition}

For simplicity, only the deterministic receive is stored to represent an instance of the orphaned receive pattern. For example, the CTP in \figref{fig:deadlock1} has a instance of the orphaned receive pattern $(r_1)$.

\subsection{Pattern Match for Orphaned Receive}

\begin{algorithm}
\caption{Finding Orphaned Receive}\label{algo:mismatch}
\begin{algorithmic}[1]
%\Require $\mathit{ctp}$, a single-path MPI program
%\Require $\mathit{M}(\mathtt{r_c}) = \{\mathtt{s_l}\mid(\mathtt{s_l},\mathtt{r_c})\in\mathit{M}\}$, a set of potentially matched sends for $\mathtt{r_c}$
%\State $\mathit{PT}$, a set of mismatched send-receive pattern instances
%\State $\mathit{R}(p) = \{\mathtt{r_w}\mid(p,\mathtt{r_w})\in\mathit{R}\}$, a set of wildcard receives on process $p$
\State $\mathit{PT} \gets \emptyset$
\State $\mathit{R} \gets \emptyset$
\For{$(e_1, e_2, \dots, e_n) \in \mathit{ctp}$}
\For{$i \gets 1$ to $n$}
\If{$e_i$ is a wildcard receive}
\State $\mathit{R} = \mathit{R} \cup \{e_i\}$
\EndIf
\If{$e_i$ is a deterministic receive}
\For{$\mathit{r_w} \in \mathit{R}$}
\If{$\mathit{M}(e_i) \cap \mathit{M}(\mathit{r_w}) \neq \emptyset \wedge |\mathit{M}(\mathit{r_w})| > 1$}
\State $\mathit{PT} = \mathit{PT} \cup \{\{e_i\}\}$
\State \textbf{break}
\EndIf
\EndFor
\EndIf
\EndFor
\State $\mathit{R} \gets \emptyset$
\EndFor
%\EndProcedure
\end{algorithmic}
\end{algorithm}

\algoref{algo:mismatch} shows the steps of finding the orphaned receive pattern instances for \textit{ctp}. The algorithm is part of the function $\mathrm{PATTERNMATCH}$ in \algoref{algo:main}.  
The set $\mathit{PT}$ stores the matched pattern instances.
The set $\mathit{R}$ stores the witnessed wildcard receives on the process \textit{p} that is a list of operations $(e_1, e_2, \dots, e_n)$. 
Intuitively, this algorithm checks each pair of wildcard/deterministic receives on an identical process and inserts a new instance into $\mathit{PT}$ if the criteria in \defref{def:mismatch} is satisfied for this pair. 
The complexity of the algorithm is $O(\mathrm{N}^2)$, where $\mathrm{N}$ is the total number of operations in \textit{ctp}. 

The completeness for \algoref{algo:mismatch} is given in \lemmaref{lemma:pmorphaned}. 

\begin{lemma}
\label{lemma:pmorphaned}
The pattern match in \algoref{algo:mismatch} is complete indicating that all possible pattern instances are detected.
\end{lemma}
\begin{proof}
\algoref{algo:mismatch} considers all possible pairs of wildcard/deterministic receives on each process. Also, only the pairs that never cause an orphaned deterministic receive are removed by the condition at line 10, because 1) there does not exist any common send that can potentially match the wildcard receive and the deterministic receive, or 2) there is no non-deterministic choice for the wildcard receive to be matched with. 
Therefore, all possible instances for the orphaned receive pattern are detected. 
\end{proof}

%%add text for the following algorithm of validating orphaned receive pattern
\subsection{Validation for Orphaned Receive}

\begin{algorithm}
\caption{Validate Orphaned Receive}\label{algo:vorphaned}
\begin{algorithmic}[1]
%\Require $\mathit{M}(\mathtt{r_c}) = \{\mathtt{s_l}\mid(\mathtt{s_l},\mathtt{r_c})\in\mathit{M}\}$, a set of potentially matched sends for $\mathtt{r_c}$
%\State  $\mathit{ctp_s}$, a potential schedule detected by the Call {FeasibleCheck}{}{}
\If{\textproc{SAT}({\Call {Encode}{$\mathit{ctp}_s$, $\mathit{pt}$, $\mathit{M}$}})}
\State report deadlock and exit.
\EndIf
\end{algorithmic}
\end{algorithm}

The validation step in \algoref{algo:vorphaned} is much more complicated because it requires a higher cost SMT encoding for $\mathit{ctp_s}$ that is generated by a modification of the abstract machine in \figref{fig:machine}.
This modification executes a CTP just like the old machine, only it updates a new $\mathit{ctp_s}$ by adding the consumed operations when executing the machine.
The function $\mathrm{ENCODE}$ encodes $\mathit{ctp_s}$ into an SMT problem based on the rules in \cite{DBLP:conf/kbse/HuangMM13}. Further, a new rule is added to the encoding: for the receive $\mathit{r_c}$ in the pattern instance \textit{pt}, $\bigvee_{\mathit{r_i}\in\mathit{M}(\mathit{s_l})}(\mathit{s_l},\mathit{r_i})$ is encoded for any send $\mathit{s_l}\in\mathit{M}(\mathit{r_c})$ in $\mathit{ctp_s}$. This rule ensures that no send in $\mathit{ctp_s}$ can match $\mathit{r_c}$. The function $\mathrm{SAT}$ is true if the encoding is satisfiable. The existence of a satisfying assignment of the encoding implies a real deadlock for \textit{pt}. 

\examplefigtwo

The existence of a orphaned receive pattern instance does not mean a deadlock occurs. For example, the CTP in \figref{fig:nodeadlock1} has an instance of the orphaned receive pattern $(r_1)$ that is detected by \algoref{algo:mismatch}. However, \algoref{algo:vorphaned} reports no real deadlock for this pattern instance because the wildcard receive $r_0$ can only match the send $s_2$ so the receive $r_1$ can be matched eventually.

%%Soundness proof for pattern match needs to be added. the following proof needs to be revised to show that the validation is sound and complete.
The soundness proof of the validation in \algoref{algo:vorphaned} is given in \lemmaref{lemma:mismatch}.

\begin{lemma}
The validation method implementing \algoref{algo:vorphaned} for an instance of the orphaned receive pattern, $\mathit{pt}$, is sound and complete indicating that any detected deadlock is a real deadlock and any instance rejected by \algoref{algo:vorphaned} is a not a real deadlock. 
\label{lemma:mismatch}
\end{lemma}
\begin{proof}
The soundness and completeness relies on the correctness proof of the SMT encoding \cite{DBLP:conf/kbse/HuangMM13}. In general, a satisfying assignment returned by \algoref{algo:vorphaned} represents a feasible schedule leading to an orphaned receive. Therefore, a real deadlock is detected. If the SMT encoding is unsatisfiable indicating that no schedules can be resolved for $pt$, then no real deadlock may occur.
\end{proof}

%The SMT encoding used in the validation step for the orphaned receive pattern can be solved by a state-of-art SMT solver Z3 with a higher cost \cite{demoura:tacas08}. The general algorithm, however, can be modified to remove the validation for the orphaned receive pattern, which leads to a much faster deadlock detection. If so, the algorithm is not sound. The completeness, however, is maintained.

%%zero buffer for orphaned receive

