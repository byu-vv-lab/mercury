\section{Related Work}
The approach in this paper is inspired by several works. The predictive analysis collects a single trace and predicts deadlocks in the other traces with the same input  \cite{DBLP:conf/sc/SharmaGB12,Subodh:Dissertation}. The dependency constructor in this approach refines the match paris that may lead to a deadlock.

Joshi et al. proposed a method that finds real deadlocks for multi-threaded Java programs by first detecting potential lock dependency cycles with a imprecise dynamic analyzer and then creating real deadlocks by a random thread scheduler with high probability \cite{DBLP:conf/pldi/JoshiPSN09}. This method scales to large programs. Also, the method detects a number of previously unknown deadlocks in a set of benchmarks. 

A precise SMT encoding technique is proposed for detecting user-provided assertions for MCAPI (another message passing standard) programs \cite{DBLP:conf/kbse/HuangMM13}. The encoding is sound and complete and is easy to use to reason about infinite buffer semantics without requiring a precise match set. The work also provides an algorithm that runs in quadratic time complexity to generate a sufficiently small over-approximated match set based on the given execution trace. This approach is extended to checking zero buffer incompatibility for MPI semantics \cite{HuangNFM15}. The extended approach provides a set of simple rules for encoding zero buffer semantics.

Comparing the approach in this paper with three works above \cite{DBLP:conf/sc/SharmaGB12,Subodh:Dissertation,DBLP:conf/pldi/JoshiPSN09,DBLP:conf/kbse/HuangMM13}. The main framework of the algorithm in this paper is inspired by the refining strategy of \cite{DBLP:conf/pldi/JoshiPSN09} that creates deadlocks from lock dependency cycles, only this paper intends to prune the set of potential deadlock instances for deadlock detection. This paper is also inspired by the counting rules in the predictive analysis \cite{DBLP:conf/sc/SharmaGB12,Subodh:Dissertation}, but these rules are not used to refine the match pairs in this paper. Further, the SMT encoding used in this paper is relied on the work for MCAPI verification \cite{DBLP:conf/kbse/HuangMM13}. However, it is applied to MPI verification in this paper.

There are other solutions for message program analysis.
The dynamic analyzer ISP implements the POE algorithm, a Dynamic Partial Order Reduction (DPOR) algorithm \cite{DBLP:conf/popl/FlanaganG05} applied to MPI programs \cite{DBLP:conf/ppopp/VakkalankaSGK08}. An extension is the MSPOE algorithm \cite{DBLP:conf/sbmf/SharmaGB12}. It operates by postponing the cooperative operations for message passing in transit until each process reaches a blocking call. It then determines the potential matches of send and receive operations in the runtime. In addition to program properties, it is able to check deadlocks.

Forejt et al. proposed a SAT based approach to detect deadlock in a single-path MPI program \cite{DBLP:conf/fm/ForejtKNS14}. This solution is correct and efficient for the programs with a low degree of message non-determinism. However, since the size of their encoding is cubic, checking large programs is time consuming. Similar to our solution, this work requires a match pair set that can be over-approximated.

 

MPI-Spin is integrated in the classic model checker, SPIN \cite{DBLP:journals/tse/Holzmann97}, for verifying MPI programs \cite{DBLP:conf/vmcai/Siegel07,DBLP:conf/pvm/Siegel07}. It generates a model of an MPI program and symbolically executes it. It does not scale to large programs with a large degree of message non-determinism.

Vo et al. used Lamport clocks to update the auxiliary information via piggyback messages \cite{DBLP:conf/sc/VoAGSSB10,DBLP:conf/IEEEpact/VoGKSSB11}. While completeness is abandoned in their analysis, they show this work is useful and efficient in practice. 

Sharma et al. proposed the first push button model checker for MCAPI -- MCC \cite{DBLP:conf/fmcad/SharmaGMH09}. It indirectly controls the MCAPI runtime to verify MCAPI programs under zero buffer semantics. An obvious drawback of this work is its inability to analyze infinite buffer semantics which is known as a common runtime environment in message passing. A key insight, though, is the direct use of match pairs -- couplings for potential sends and receives.

Elwakil et al. also used SMT techniques to reason about the program behavior in the MCAPI domain \cite{DBLP:conf/issta/ElwakilY10,DBLP:conf/atva/ElwakilYW10}. State-based and order-based encoding techniques are both used. These techniques fail to reason about the infinite buffer semantics and require a precise match set which is non-trivial to compute beforehand.

