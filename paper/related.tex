\section{Related Work}
The approach in this presentation is inspired by several works. The predictive analysis collects a single trace and predicts deadlocks in the other traces with the same input  \cite{DBLP:conf/sc/SharmaGB12,Subodh:Dissertation}. The dependency constructor in the work refines the match pairs that may lead to a deadlock. The refining strategy uses simple counting rules that inspires the abstract machine in this presentation. However, the approach in this presentation does not refine the match pairs for deadlock detection.

Joshi et al. proposed a method that finds real deadlocks for multi-threaded Java programs by first detecting potential lock dependency cycles with a imprecise dynamic analyzer and then finding real deadlocks by a random thread scheduler with high probability \cite{DBLP:conf/pldi/JoshiPSN09}. The solution scales to large programs. Also, the method detects a number of previously unknown deadlocks in a set of benchmarks. The refining strategy of the work also inspires the general algorithm in this presentation, only this presentation intends to prune a set of potential deadlock instances instead of finding deadlocks from an instance.

A precise SMT encoding technique is proposed for detecting user-provided assertions for MCAPI programs \cite{DBLP:conf/kbse/HuangMM13}. The encoding is sound and complete and is easy to use to reason about infinite buffer semantics without requiring a precise match set. The work also provides an algorithm that runs in quadratic time complexity to generate a sufficiently small over-approximated match set based on the given execution trace. This approach is extended to checking zero buffer incompatibility for MPI semantics \cite{HuangNFM15}. 
%The extended approach provides a set of simple rules for encoding zero buffer semantics. 
The technique is also used for deadlock detection for MPI programs in this presentation.

%Comparing the approach in this paper with three works above \cite{DBLP:conf/sc/SharmaGB12,Subodh:Dissertation,DBLP:conf/pldi/JoshiPSN09,DBLP:conf/kbse/HuangMM13}. The main framework of the algorithm in this paper is inspired by the refining strategy of \cite{DBLP:conf/pldi/JoshiPSN09} that creates deadlocks from lock dependency cycles, only this paper intends to prune the set of potential deadlock instances for deadlock detection. This paper is also inspired by the counting rules in the predictive analysis \cite{DBLP:conf/sc/SharmaGB12,Subodh:Dissertation}, but these rules are not used to refine the match pairs in this paper. Further, the SMT encoding used in this paper is relied on the work for MCAPI verification \cite{DBLP:conf/kbse/HuangMM13}. However, it is applied to MPI verification in this paper.

There are other solutions for message passing program analysis.
The dynamic analyzer ISP implements the POE algorithm, a Dynamic Partial Order Reduction (DPOR) algorithm \cite{DBLP:conf/popl/FlanaganG05} applied to MPI programs \cite{DBLP:conf/ppopp/VakkalankaSGK08}. 
An extension is the MSPOE algorithm \cite{DBLP:conf/sbmf/SharmaGB12}. It operates by postponing the cooperative operations for message passing in transit until each process reaches a blocking call. It then determines the potential matches of send and receive operations in the runtime. The solution is able to detect errors such as assertion violation and deadlock in an MPI program.
A drawback of ISP is that it does not scale for large programs due to state explosion.

Forejt et al. proposed a SAT based approach to detect deadlock in a single-path MPI program \cite{DBLP:conf/fm/ForejtKNS14}. The solution is correct and efficient for programs with a low degree of message non-determinism. However, since the size of their encoding is cubic, checking large programs is time consuming. Similar to the solution in this presentation, the work requires a match pair set that can be over-approximated.

Umpire is an approach of runtime verification for checking multiple MPI errors such as deadlock and resource tracking \cite{DBLP:conf/sc/VetterS00}. The error checking is taken by spawning one manger thread and several outfielder threads in the execution of an MPI program. The tool fails for two reasons. First, the deadlock detection only considers dependency cycles, therefore, is not able to detect deadlock for orphaned receive pattern. Second, it does not scale well since the asynchronous trace transfer highly depends on the thread interleavings which are exponential. An extension to Umpire is Marmot \cite{DBLP:conf/parco/KrammerBMR03}. The work uses a centralized sever instead of multiple threads for error checking. Marmot is able to check local errors. However, it suffers from the same disadvantage of Umpire. Another extension to Umpire is MUST \cite{DBLP:conf/ptw/HilbrichSSM09}. The structure of MUST allows the users to execute the error checking either in an application process itself or in extra processes that are used to offload these analyses. Therefore, MUST scales to programs with more than 1,000 processes. However, just like Umpire and Marmot, the approach is neither sound nor complete for deadlock detection. 


MPI-Spin is integrated in the model checker SPIN \cite{DBLP:journals/tse/Holzmann97}, for verifying MPI programs \cite{DBLP:conf/vmcai/Siegel07,DBLP:conf/pvm/Siegel07}. It generates a model of an MPI program and symbolically executes it. It does not scale to large programs with a large degree of message non-determinism.

Vo et al. used Lamport clocks to update the auxiliary information via piggyback messages \cite{DBLP:conf/sc/VoAGSSB10,DBLP:conf/IEEEpact/VoGKSSB11}. While completeness is abandoned in their analysis, they show the work is useful and efficient in practice. 

Sharma et al. proposed the first push button model checker for MCAPI -- MCC \cite{DBLP:conf/fmcad/SharmaGMH09}. It indirectly controls the MCAPI runtime to verify MCAPI programs under zero buffer semantics. An obvious drawback of the work is its inability to analyze infinite buffer semantics which is known as a common runtime environment in message passing. A key insight, though, is the direct use of match pairs -- couplings for potential sends and receives.

Elwakil et al. also used SMT techniques to reason about the program behavior in the MCAPI domain \cite{DBLP:conf/issta/ElwakilY10,DBLP:conf/atva/ElwakilYW10}. State-based and order-based encoding techniques are both used. These techniques fail to reason about the infinite buffer semantics and require a precise match set which is non-trivial to compute beforehand.

