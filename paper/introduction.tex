\section{Introduction}
%The Message Passing Interface (MPI) is widely used in high performance computing (HPC). A common problem in any MPI program, is communication deadlock. A communication deadlock is ``\emph{a situation in which each member process of the group is waiting for some member process to communicate with it, but no member is attempting to communicate with it}" \cite{DBLP:conf/fsttcs/Natarajan84}. This paper refers to a communication deadlock as deadlock. 

The Message Passing Interface (MPI) is widely used in high performance computing (HPC). A common problem in any MPI program is deadlock. The deadlock problem for a single-path MPI program is NP--Complete \cite{DBLP:conf/fm/ForejtKNS14}.
This paper considers only single-path MPI programs that are typical of many HPC applications and the standard for most deadlock analysis tools.  

Deadlock in a single-path MPI program is difficult to detect because of several reasons. First, message races, intended or not, lead to message non-determinism because a receive may be matched with more than one send by the runtime. This non-determinism is difficult to test or debug. Second, the collective operations, such as barriers, synchronize a program in complex ways leading to unexpected behaviors. And finally, there are two buffering semantics: infinite buffer semantics (messages are buffered in the system) and zero buffer semantics (no buffering in the system) that lead to different runtime behaviors. All of these aspects make testing and debugging for deadlock very difficult. 

There are several solutions that use match pairs for deadlock detection which do not scale for large programs \cite{DBLP:conf/ppopp/VakkalankaSGK08, DBLP:conf/sbmf/SharmaGB12, DBLP:conf/fm/ForejtKNS14}. A match pair consists of a send and a receive that may potentially match the send by the runtime. There are also static analysis based solutions that are able to scale well \cite{DBLP:conf/sc/SharmaGB12, DBLP:conf/pldi/JoshiPSN09, Subodh:Dissertation}. The general algorithm in this paper is inspired by such work.

This paper presents a new algorithm that is able to detect a deadlock for a single-path MPI program in three steps. First, the algorithm uses a static analyzer to detect a set of deadlock pattern instances by statically traversing the program and matching patterns to program. The algorithm then uses an abstract machine to prune provably non-feasible pattern instances from the set of potential deadlocks. If needed, the algorithm finally validates whether or not any remaining instances imply a real deadlock. Novel in the approach is the abstract machine efficiently rejects non-feasible instances by simply counting the issued sends and receives, instead of exhaustively enumerating all message races. The complexity of the abstract machine is quadratic in the number of communications. 

This paper further defines two distinct patterns of deadlock and their validations: circular dependency and orphaned receive. A circular dependency pattern may cause a program to deadlock if there exists a cycle among a group of processes where a receive on each member process waits for the issuing of a send on another member process but never gets a response. An orphaned receive pattern may also cause a program to deadlock if there exists a pair of receives both on the same process, one being a wildcard (a receive that may match a send from any source) and the other being a deterministic receive (a receive that only matches a send from a fixed source). The deadlock occurs when the runtime matches the wildcard receive to the send needed by the deterministic receive. 

This paper presents how to detect all the instances for each of the patterns above by statically traversing the program. Further, this paper presents how to validate the instances of the circular dependency pattern by simply comparing the counts of issued operations. For the orphaned receive pattern, this paper shows the validation that requires a higher cost SMT encoding to identify a real deadlock. 

This paper additionally gives proofs that the general algorithm is sound and complete for the circular dependency pattern and the orphaned receive pattern. Also, the experiments compares the new approach in this paper with two state-of-art MPI verifiers. The results show that the new approach scales for large benchmark programs while other tools time out.

%As a note, the algorithm is designed for infinite buffer semantics. Nevertheless, it is adaptable to zero buffer semantics with a few changes in deadlock validation.

The contributions are summarized as follows.
\begin{itemize}
\item The key contribution is an abstract machine that is able to efficiently prune non-feasible pattern instances from a set of potential deadlocks without false warnings; 
\item The second contribution is the definition of two typical patterns: circular dependency and orphaned receive, and their validations;
\item The third contribution is the implementation of the algorithm in the paper for MPI deadlock detection and a set of benchmarks that demonstrate it is more efficient than two state-of-art MPI verifiers.
\end{itemize}

%%add text such that these two patterns cover most deadlock situations. 

%The rest of the paper is organized as follows: Sections 2 introduces a few notations and definitions for an MPI program; Section 3 presents the main framework of the technique in the paper with a soundness and completeness proof, Section 4 and 5 present the circular dependency pattern and the orphaned receive pattern with a few examples, the pattern matching algorithms and the validation algorithms; Section 6 gives the experimental results; Section 7 discusses the related work; and Section 8 discusses the conclusion and future work.
