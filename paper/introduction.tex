\section{Introduction}
Message passing is widely used in high performance computing (HPC). A common problem in any message passing program, is communication deadlock. A communication deadlock is ``a situation in which each member process of the group is waiting for some member process to communicate with it, but no member is attempting to communicate with it" \cite{DBLP:conf/fsttcs/Natarajan84}. This paper refers to a communication deadlock as deadlock in the following discussion. 

Deadlock is hard to detect because of the complicated semantics. In particular, messages are communicated in a non-deterministic way such that a receive may be matched with more than one send in the runtime system. Also, the message communication is impacted by two buffering semantics: infinite buffer semantics (messages are buffered in the system) and zero buffer semantics (no buffering in the system). Further, the control flow decisions based on random input or non-deterministic messages make the problem difficult. As many message passing programs are implemented as single-path programs, which do not consider the complexity of control flow decisions, we only use single-path programs in the following discussion. The deadlock problem for a single-path message passing program is NP--Complete \cite{DBLP:conf/fm/ForejtKNS14}.

To detect a deadlock in any single-path program, this paper defines two typical patterns of deadlock in a message passing program: mismatched send and receive pairs and circular dependency in messages. A mismatched send and receive pairs may cause a program deadlock if a receive is mismatched with a send and there is no way to match a following receive on the same process. A circular dependency in messages may also cause a program deadlock if there exists a circle among a group of processes where a receive on each member process waits the issuing of a send on another member process but never gets a response. Note that the existence of a pattern instance is only a potential deadlock. To check if it may occur in the runtime system, this paper presents a static analysis based approach for both deadlock patterns.   

Several solutions are proposed for deadlock detection. Dynamic analysis includes the POE algorithm that is capable of analyzing the behavior of Message Passing Interface (MPI) programs \cite{DBLP:conf/ppopp/VakkalankaSGK08}. This algorithm is implemented by a modern MPI verifier, ISP. An extension is the algorithm MSPOE that is designed to detect deadlock in an MPI program \cite{DBLP:conf/sbmf/SharmaGB12}. The problem can also be checked by SAT/SMT technique. Forejt et al. proposed a SAT based approach to detect deadlock in a single-path MPI program \cite{DBLP:conf/fm/ForejtKNS14}. As far as we know, these two approaches are the only existing works in message passing deadlock detection. Unfortunately, they do not scale well for several benchmark program. This paper show the experimental result later. In the field of shared memory programs, Joshi et al. proposed a technique that uses a random thread scheduler to create the potential deadlocks that are detected by an imprecise dynamic analyzer \cite{DBLP:conf/pldi/JoshiPSN09}. This approach is able to check large multi-threaded programs and does not give any false warnings. 

This paper presents a new algorithm that is able to detect a deadlock for a message passing program based on two types of patterns mentioned above in two steps. In the first step, the algorithm uses a static analysis to detect a set of pattern instances by statically traversing the program and detecting all the instances that satisfy the criteria of the two patterns (defined later). In the second step, the algorithm uses another low-cost static analysis to prune infeasible pattern instances from the set of potential deadlocks, which is sufficient to identify real deadlock from circular dependency, and then using a higher cost SMT encoding to identify real deadlock from send and receive mismatch. The complexity of the algorithm is quadratic. The SMT encoding used for the mismatched send and receive pattern is extended from the prior work \cite{DBLP:conf/kbse/HuangMM13,HuangNFM15}.  

The contributions are summarized as follows.
\begin{itemize}
\item The key contribution is a new static analysis based algorithm that is able to prune infeasible instances for two types of deadlock patterns and then to detect a real deadlock schedule without false warnings. 
\item The second contribution is a new algorithm that detects all the instances of the mismatched send and receive pattern and the circular dependency pattern by statically traversing the program; and
\item The third contribution is the implementation of the algorithm in this paper for MPI deadlock detection and a set of benchmarks that demonstrate it is more efficient than two state-of-art MPI verifiers.
\end{itemize}

The rest of the paper is organized as follows: Sections 2 introduces a few notations and definitions for an MPI program; Section 3 presents the new algorithm for deadlock detection, including the definition of two types of deadlock patterns, a few examples showing the patterns, the new algorithm for pattern detection, the new deadlock schedule finder and the correctness proofs for this algorithm; Section 4 gives the experimental results; Section 5 discusses the related work; and Section 6 discusses the conclusion and future work.
