\section{Introduction}
Message Passing Interface (MPI) is widely used in high performance computing (HPC). A common problem in any MPI program, is communication deadlock. A communication deadlock is ``\emph{a situation in which each member process of the group is waiting for some member process to communicate with it, but no member is attempting to communicate with it}" \cite{DBLP:conf/fsttcs/Natarajan84}. This paper refers to a communication deadlock as deadlock in the following discussion. 

This paper considers only single-path MPI programs because: 1) they are typical of many HPC applications and the standard for most deadlock analysis tools, and 2) the deadlock problem for a single-path MPI program is NP--Complete \cite{DBLP:conf/fm/ForejtKNS14}. There are two reasons that lead deadlocks in a single-path message passing program hard to detect. In particular, messages are communicated in a non-deterministic way such that a receive may be matched with more than one send in the runtime system. Also, the message communication is impacted by two buffering semantics: infinite buffer semantics (messages are buffered in the system) and zero buffer semantics (no buffering in the system). 

Several solutions are proposed for deadlock detection. Dynamic analysis includes the POE algorithm that is capable of analyzing the behavior of Message Passing Interface (MPI) programs \cite{DBLP:conf/ppopp/VakkalankaSGK08}. This algorithm is implemented by a modern MPI verifier, ISP. An extension is the algorithm MSPOE that is designed to detect deadlock in an MPI program \cite{DBLP:conf/sbmf/SharmaGB12}. The problem can also be checked by SAT/SMT technique. Forejt et al. proposed a SAT based approach to detect deadlock in a single-path MPI program \cite{DBLP:conf/fm/ForejtKNS14}. As far as we know, these two approaches are the only existing works in message passing deadlock detection. Unfortunately, they do not scale well for several benchmark program. This paper show the experimental result later. In the field of shared memory programs, Joshi et al. proposed a technique that uses a random thread scheduler to create the potential deadlocks that are detected by an imprecise dynamic analyzer \cite{DBLP:conf/pldi/JoshiPSN09}. This approach is able to check large multi-threaded programs and does not give any false warnings. 

This paper presents a new algorithm that is able to detect a deadlock for a single-path MPI program in three steps. First, the algorithm uses a static analyzer to detect a set of pattern instances by statically traversing the program. The algorithm then uses an abstract machine to prune non-feasible pattern instances from the set of potential deadlocks. If needed, the algorithm finally validates whether or not any feasible instance implies a real deadlock. Instead of exhaustively enumerating all message races, the novelty is that the abstract machine efficiently rejects non-feasible instances by simply counting the issued sends and receives. The complexity of the algorithm is quadratic. 

The paper further defines two distinct patterns of deadlock and their validations: circular dependency and orphaned receive. A circular dependency pattern may cause a program deadlock if there exists a cycle among a group of processes where a receive on each member process waits the issuing of a send on another member process but never gets a response. An orphaned receive pattern may also cause a program deadlock if there exists a pair of a wildcard receive (a receive that may match a send from any source) and a deterministic receive (a receive that may match a send from a fixed source) on an identical process. The deadlock occurs when the wildcard receive is matched with a send that should match the deterministic receive in runtime. The paper also presents how to detect and validate the instances for each pattern above.

The paper additionally gives proofs that the algorithm is sound and complete for circular dependency pattern and that it is sound for orphaned receive pattern. To make the algorithm complete for orphaned receive pattern, a high-cost SMT encoding extended from the prior work (\cite{DBLP:conf/kbse/HuangMM13,HuangNFM15}) is required to identify a real deadlock. As a note, the algorithm is designed for infinite buffer semantics. Nevertheless, it is adaptable to zero buffer semantics with a few changes in deadlock validation.

The contributions are summarized as follows.
\begin{itemize}
\item The key contribution is an abstract machine that is able to statically prune non-feasible pattern instances from a set of potential deadlocks without false warnings; 
\item The second contribution is the definition of two typical patterns: circular dependency and orphaned receive, and their validations;
\item The third contribution is the implementation of the algorithm in the paper for MPI deadlock detection and a set of benchmarks that demonstrate it is more efficient than two state-of-art MPI verifiers.
\end{itemize}

%%add text such that these two patterns cover most deadlock situations. 

The rest of the paper is organized as follows: Sections 2 introduces a few notations and definitions for an MPI program; Section 3 presents the main framework of the technique in the paper with a soundness and completeness proof, Section 4 and 5 present the circular dependency pattern and the orphaned receive pattern with a few examples, the pattern matching algorithms and the validation algorithms; Section 6 gives the experimental results; Section 7 discusses the related work; and Section 8 discusses the conclusion and future work.
