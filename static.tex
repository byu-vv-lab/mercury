\section{Algorithm}

\examplefigone

The algorithm in this paper consists of several steps shown in \algoref{algo:main}. The function $\mathrm{PATTERNFINDER}$ at line 3 computes two types of deadlock patterns (defined later) by running \algoref{algo:mismatch} and \algoref{algo:circular} in sequence, where each statically traverses the program. The function $\mathrm{SCHEDULEFINDER}$ at line 5, again, statically traverses the program and finds a potential schedule $\mathit{ctp}_s$. The variable $\mathit{empty}_{pt}$ returned by $\mathrm{SCHEDULEFINDER}$ is true if all the receives in the pattern instance \textit{pt} are witnessed after the schedule is detected. \algoref{algo:main} further checks the feasibility of this schedule with different strategies for the two types of deadlocks. The functions $\mathrm{isCircular}$ and $\mathrm{isMismatch}$ check the types of deadlock patterns. If \textit{pt} is a circular dependency instance, the condition at line 11 in \algoref{algo:main} checks whether there exists a send in the schedule that may match any receive $\mathit{r}$ in \textit{pt}. If the condition is true for some $\mathit{r}$ in \textit{pt}, then the instance is not a real deadlock because $\mathit{r}$ is matched and the circle in \textit{pt} does not hold. Once all the receives in \textit{pt} are checked such that they can not be matched to any sends in the schedule, then the feasibility of the schedule is witnessed. If \textit{pt} is a mismatched send and receive instance, the function $\mathrm{ENCODE}$ in \algoref{algo:main} encodes the schedule into an SMT problem based on the rules in \cite{DBLP:conf/kbse/HuangMM13}. Further, a new rule is extended for the match pair encoding: for any deterministic receive $\mathtt{r_c}$ in\textit{pt}, $\bigvee_{\mathtt{r_i}\in\mathit{M}(\mathtt{s_l})}(\mathtt{s_l},\mathtt{r_i})$ is encoded for any $\mathtt{s_l}\in\mathit{M}(\mathtt{r_c})$ in the schedule. This rule ensures that no send in the schedule can match $\mathtt{r_c}$. The function $\mathrm{SAT}$ is true if the encoding is satisfiable. The existence of a satisfying assignment of the encoding implies that the schedule is feasible. The algorithm aborts the verification process once a deadlock is found at line 15 or line 19. As a note, the algorithm is only applied for verifying programs under infinite buffer semantics. If the zero buffer semantics are enforced, the algorithm needs to be modified as discussed later.

%The algorithm requires a single-path MPI program, $\mathit{ctp}$, as input. In the first step, the function $\mathrm{PATTERNFINDER}$ at line 4 traverses the program linearly and finds the instances of two types of deadlock patterns (defined below). In the second step, the function $\mathrm{SCHEDULEFINDER}$ at line 7, again, statically traverses the program and finds a potential schedule $\mathit{ctp}_s$ and updates the set $\rcvp^\prime$ for each pattern instance $\mathit{pt}$. If the new set $\rcvp^\prime$ is not an empty set (at line 8), or there are more sends than receives with identical $src$ and $dest$ that are the source and destination endpoints respectively for any receive in \rcvp\ (at line 12), then the algorithm continues to check the next pattern instance. It repeats the steps above until a deadlock is found or no deadlock exists for all the pattern instances. If a schedule exists, the algorithm reports a deadlock at line 17 if the pattern instance is a circular dependency, or further checks the feasibility of the schedule by encoding it into an SMT problem at line 20 if the pattern instance is a mismatched send-receive. The algorithm reports a deadlock at line 22 if the encoding is satisfiable, or continues to check the next pattern instance at line 25 if it is unsatisfiable. The algorithm aborts the verification process once a deadlock is found. As a note, the algorithm is only applied for verifying programs under infinite buffer semantics. To adjust zero buffer semantics, this paper presents how to modify the algorithm later.

\begin{algorithm}
\caption{Main Framework}\label{algo:main}
\begin{algorithmic}[1]
%\Procedure{Main Entrance}{}
\Require $\mathit{ctp}$, a single-path MPI program
\Require $\mathit{M}(\mathtt{r_c}) = \{\mathtt{s_l}\mid(\mathtt{s_l},\mathtt{r_c})\in\mathit{M}\}$, a set of potentially matched sends for $\mathtt{r_c}$
\State  $\mathit{PT}$, a set of pattern instances
\State  $\mathit{pt}$, a set of receives in the pattern instance $\mathit{pt}\in\mathit{PT}$
\State  $\mathit{PT} \gets$ \Call {PatternFinder}{$\mathit{ctp}$, $\mathit{M}$}
\State \emph{point:}
\For{$\mathit{pt} \in \mathit{PT}$}
\State ($\mathit{ctp}_s, \mathit{N_s}, \mathit{N_r}, \mathit{empty}_{pt}) \gets$ \Call {ScheduleFinder}{$\mathit{pt}$}
\If{$\mathit{empty}_{pt}$} 
\If{\Call{isCircular}{$\mathit{pt}$}}
\For{$\mathtt{r_c}\in\mathit{pt}$}
\State $\mathit{src} \gets$ source endpoint of $\mathtt{r_c}$, $\mathit{dest} \gets$ destination endpoint of $\mathtt{r_c}$
\If{$\mathit{N_s}(\mathit{dest},\mathit{src}) > \mathit{N_r}(\mathit{dest},\mathit{src})$}
\State \textbf{continue} \textit{point}
\EndIf
\EndFor
\State report deadlock and exit.
\EndIf
\If{\Call {isMismatch}{$\mathit{pt}} \in$}
\If{\textproc{SAT}({\Call {Encode}{$\mathit{ctp}_s$}})}
\State report deadlock and exit.
\EndIf
\EndIf
\EndIf
\EndFor
%\EndProcedure
\end{algorithmic}
\end{algorithm}

\subsection{Finding Pattern Instances}

A deadlock may occur if sends and receives are mismatched because of the existence of deterministic receives. For instance, in \figref{fig:deadlock1}, a deadlock may occur if $\mathtt{s_{12}}$ matches $\mathtt{r_{01}}$ and there is no way to match $\mathtt{s_{20}}$ with $\mathtt{r_{03}}$. This program shows an instance of the mismatched send-receive pattern that is a set of the underlined operations. Only the deterministic receive $\mathtt{r_{03}}$ is stored to represent the pattern instance defined in \defref{def:mismatch}.


\begin{definition}
A mismatched send and receive pattern is matched when there exists a deterministic receive $\mathtt{r_c}$ where, 
\begin{compactenum}
\item there exists a wildcard receive $\mathtt{r_w}$ followed by $\mathtt{r_c}$ on a single process $\mathit{p}$; 
\item at least two sends from different source endpoints other than $\mathit{p}$ may potentially match $\mathtt{r_w}$; and
\item among these matched sends, at least one send matches $\mathtt{r_c}$. 
\end{compactenum}
\label{def:mismatch}
\end{definition}

\examplefigtwo

The existence of a pattern instance does not mean a deadlock occurs. The program in \figref{fig:nodeadlock1} is such an instance. This pattern instance is detected, but is pruned at line $17$ in \algoref{algo:main} because there does not exist a feasible schedule (a schedule that is allowed by MPI semantics).



\begin{algorithm}
\caption{Finding Mismatched Send-Receive}\label{algo:mismatch}
\begin{algorithmic}[1]
\Require $\mathit{ctp}$, a single-path MPI program
\Require $\mathit{M}(\mathtt{r_c}) = \{\mathtt{s_l}\mid(\mathtt{s_l},\mathtt{r_c})\in\mathit{M}\}$, a set of potentially matched sends for $\mathtt{r_c}$
\State $\mathit{PT}$, a set of mismatched send-receive pattern instances
\State $\mathit{R}(p) = \{\mathtt{r_w}\mid(p,\mathtt{r_w})\in\mathit{R}\}$, a set of wildcard receives on process $p$
\For{$p \in \mathit{ctp}$}
\For{$\mathtt{r_c} \in p$}
\If{$\mathtt{r_c}$ is a wildcard receive}
\State $\mathit{R} = \mathit{R} \cup \{(p,\mathtt{r_c})\}$
\EndIf
\If{$\mathtt{r_c}$ is a deterministic receive}
\For{$\mathtt{r_w} \in \mathit{R}(p)$}
\If{$\mathit{M}(\mathtt{r_c}) \cap \mathit{M}(\mathtt{r_w}) \neq \emptyset \wedge |\mathit{M}(\mathtt{r_w})| > 1$}
\State $\mathit{PT} = \mathit{PT} \cup \{\{\mathtt{r_c}\}\}$
\State \textbf{break}
\EndIf
\EndFor
\EndIf
\EndFor
\EndFor
%\EndProcedure
\end{algorithmic}
\end{algorithm}

\algoref{algo:mismatch} shows the steps for finding the mismatched send and receive pattern instances for an MPI program. In general, the algorithm is part of the function $\mathrm{PATTERNFINDER}$ in \algoref{algo:main}. It requires a single-path MPI program $\mathit{ctp}$ and the preprocessed match pair set $\mathit{M}$ as input. A match pair is a coupling of a receive and a send that may match in the runtime system.
%For each process $p$ in the program, the algorithm checks each receive $\mathtt{R}$. If $\mathtt{R}$ is a wildcard receive, then it is inserted into the set $\mathit{Rset}[p]$. if it is a deterministic receive, then the algorithm checks all the stored wildcard receives in $\mathit{Rset}[p]$. If there exists a wildcard receive $\mathtt{R_w} \in \mathit{Rset}[p]$ such that $\mathtt{R}$ and $\mathtt{R_w}$ have at least two common sends, then $\mathtt{R}$ is inserted into the set of mismatched send-receive pattern instances $\mathit{Pset}$. 
The complexity of the algorithm is $O(\mathrm{N}^2)$, where $\mathrm{N}$ is the total number of operations in the program. 
%Take the program in \figref{fig:deadlock1} as an example. \algoref{algo:mismatch} traverses the process $\mathtt{P0}$ and detects that the wildcard receive $\mathtt{R_{0,1}}$ is followed by the deterministic receive $\mathtt{R_{0,3}}$ and they have two common potential matched sends $\mathtt{S_{1,2}}$ and $\mathtt{S_{2,0}}$. Therefore, $\mathtt{R_{0,3}}$ satisfies the requirement of a mismatched send-receive pattern instance. 

A deadlock may also occur when there exists a circular dependency in messages. This circular dependency is defined in \defref{def:circular} that depends on the sequential relation defined in \defref{def:seqrelation}.

\begin{definition}
A sequential relation for a process, $p$, is a three-tuple $(p, \mathtt{r_c}, \mathtt{s_l})$, where the receive $\mathtt{r_c}$ and its nearest-enclosing wait $\mathtt{w_d}$ are both followed by a send $\mathtt{s_l}$ on $p$. 
\label{def:seqrelation}
\end{definition}

\begin{definition}
Given a set of sequential relations, $D$, a circular dependency pattern $\tau$ $=$ $\langle(p_0, \mathtt{r}_0, \mathtt{s}_0),$ $\ldots,$ $(p_m, \mathtt{r}_m, \mathtt{s}_m)\rangle$ is a sequence in $D$, such that the following properties hold.
\begin{compactenum}
\item at least two sequential relations exist in $\tau$;
\item for all distinct $i,j \in [0,m]$, $p_i \neq p_j$;
\item for all $i \in [0,m], j = (i+1) \% m$, $\mathtt{s}_i$ can potentially match $\mathtt{r}_j$;
%\item for all $i \in [1,m]$, if $\mathtt{r}_i$ is a deterministic receive, then there are no wildcard receives preceding $\mathtt{r}_i$ on $p_i$.
\end{compactenum}
\label{def:circular}
\end{definition}

\examplefigthree

\figref{fig:deadlock2} shows an MPI program with a circular dependency in messages $\langle(p_0, \mathtt{r_{01}}, \mathtt{s_{03}}),$ $(p_1, \mathtt{r_{12}}, \mathtt{s_{14}}),$ $(p_1, \mathtt{r_{20}}, \mathtt{s_{22}})\rangle$. Each receive in the pattern instance waits for the issuing of a send from one of the other processes but never gets a response. For instance, $\mathtt{r_{01}}$ can never match $\mathtt{s_{22}}$ because of the circular dependency. For simplicity, only receives are stored to represent a circular dependency pattern instance (e.g., $(\mathtt{r_{01}}, \mathtt{r_{12}}, \mathtt{r_{20}})$ is a pattern instance for the program in \figref{fig:deadlock2}). 

\begin{algorithm}
\caption{Finding Circular Dependency}\label{algo:circular}
\begin{algorithmic}[1]
\Require $\mathit{ctp}$, a single-path MPI program
\Require $\mathit{M}(\mathtt{r_c}) = \{\mathtt{s_l}\mid(\mathtt{s_l},\mathtt{r_c})\in\mathit{M}\}$, a set of potentially matched sends for $\mathtt{r_c}$
\State $\mathit{E} \subseteq \mathit{e}\times\mathit{e}$, a relation from an operation $\mathit{e}$ to another operation $\mathit{e}$
\State $\mathit{V}$, a set of operations
%\State $\mathit{isIssued}$, a bool variable
\State $\mathit{PT}$, a set of circular dependency pattern instances
\State $\mathit{R}(p) = \{\mathtt{r_c}\mid(p,\mathtt{r_c})\in\mathit{R}\}$, the witnessed receives on process $p$
\State $\mathit{R_w}(p) = \{\mathtt{r_c}\mid(p,\mathtt{r_c})\in\mathit{R_w}\}$, the receives for the last witnessed wait on process $p$ 
\For{$p \in \mathit{ctp}$}
\For{$\mathit{e} \in p$}
\If{$\mathit{e}$ is a receive}
%\If{$\mathit{isIssued}$ and $\mathtt{e}$ is a deterministic receive}
%\State \textbf{break}
%\EndIf
%\If{$\mathtt{e}$ is a wildcard receive}
%\State $\mathit{isIssued} \gets true$
%\EndIf
\State $\mathit{R} = \mathit{R} \cup \{(p,\mathit{e})\}$
\State $\mathit{V} = \mathit{V} \cup \{\mathit{e}\}$
\For{$\mathtt{s_l} \in \mathit{M}(\mathit{e})$} \Comment{add match relations to $\mathit{E}$}
\State $\mathit{E} = \mathit{E} \cup \{(\mathit{e},\mathtt{s_l})\}$  
\EndFor
\EndIf
\If{$\mathit{e}$ is a wait}
\For{$\mathtt{r_c} \in \mathit{R}(p)$}
\State $\mathit{R_w} = \mathit{R_w} \cup \{(p,\mathtt{r_c})\}$
\EndFor
\State $\mathit{R}(p) \gets \emptyset$ 
\EndIf
\If{$\mathit{e}$ is a send}
\State $\mathit{V} = \mathit{V} \cup \{\mathit{e}\}$
\For{$\mathtt{r_c} \in \mathit{R_w}(p)$}  \Comment{add HB relations from $\mathtt{r_c}$ to $\mathit{e}$ to $\mathit{E}$}
\State $\mathit{E} = \mathit{E} \cup \{(\mathtt{r_c},\mathit{e})\}$
\EndFor
\EndIf
\EndFor
\EndFor
\State $\mathit{PT} \gets$ \Call {Johnson}{$\mathit{V}$, $\mathit{E}$}
\end{algorithmic}
\end{algorithm}

\algoref{algo:circular} shows the steps for finding all the instances of the circular dependency pattern in a single-path MPI program $\mathit{ctp}$. In general, the algorithm is part of the function $\mathrm{PATTERNFINDER}$ in \algoref{algo:main}. It builds a graph by transforming the operations in $\mathit{ctp}$ to the vertices $\mathit{V}$ and transforming two types of relations to the edges $\mathit{E}$. To be precise, for each process $p$ in $\mathit{ctp}$, the algorithm checks each operation $\mathit{e}$. 
%If $\mathtt{e}$ is a deterministic receive and there are wildcard receives preceding $\mathtt{e}$ on a single process (property $4$ in \defref{def:circular} does not hold), then $\mathtt{e}$ is not inserted into $\mathit{V}$ at line $11$. If $\mathtt{e}$ is a wildcard receive, then the variable $\mathit{isIssued}$ is set to true. 
If $\mathit{e}$ is a receive, then the pair $(p,\mathit{e})$ is inserted into $\mathit{R}$ and $\mathit{V}$, respectively. Also, for each potentially matched send $\mathtt{s_l}$ in $\mathit{M}(\mathit{e})$, the pair $(\mathit{e},\mathtt{s_l})$ is inserted into $\mathit{E}$ indicating that a match relation from $\mathtt{s_l}$ to $\mathit{e}$ is an edge in the graph. If $\mathit{e}$ is a wait, all the receives in $\mathit{R}(p)$ are inserted to $\mathit{R_w}(p)$ and $\mathit{R}(p)$ is set to an empty set, indicating that $\mathit{e}$ is the nearest-enclosing wait for the receives in $\mathit{R}(p)$. \defref{def:seqrelation} requires for each sequential relation a receive and its nearest-enclosing wait both precede a send on a single process. Therefore, %only the receives in the set $\mathit{Wset}$ are considered to build the happens-before relation. 
if $\mathit{e}$ is a send, then the pair $(\mathtt{r_c},\mathit{e})$ is inserted into $\mathit{E}$ at line $24$ indicating that a happens-before relation from each receive $\mathtt{r_c}\in\mathit{R_w}$ to $\mathit{e}$ is an edge in the graph. Finally, the function $\mathrm{JOHNSON}$ implements the Johnson's algorithm to compute all the cycles \cite{DBLP:journals/siamcomp/Johnson75}. Since an edge in any computed cycle is either a receive-send HB relation on an identical process, or is a send-receive match relation across two processes, there exists exactly one sequential relation for any process of the cycle. Therefore, each cycle computed by the function $\mathrm{JOHNSON}$ has potential to cause deadlock. Only receives in each cycle are stored as an instance of the circular dependency pattern in the set $\mathit{PT}$. The complexity of program traversal is $O(\mathrm{N}^2)$, where $\mathrm{N}$ is the total number of operations in the program. The complexity of Johnson's algorithm is $O((\mathrm{v}+\mathrm{e})(\mathrm{c}+1))$ $\approx$ $O((\mathrm{c}+1)\mathrm{N}^2)$, where $\mathrm{v}$ is the number of vertices, $\mathrm{e}$ is the number of edges, and $\mathrm{c}$ is the number of cycles. Therefore, the total complexity of the algorithm is $O((\mathrm{c}+1)\mathrm{N}^2)$.

\examplefigfour

An instance of the circular dependency pattern does not mean a deadlock occurs. For example, the program in \figref{fig:nodeadlock2} has an instance of the circular dependency that is detected by \algoref{algo:circular}. However, it is pruned by \algoref{algo:main} because there does not exist a feasible schedule.

\subsection{Static analysis}


\begin{figure*}[tb]
\centering
\scalebox{0.9}{
\mprset{flushleft}
\begin{mathpar}

\inferrule[Sndi Command]{
  \epsnd(v_{to},v_{frm}) = v_c \\ \epsnd^\prime = \epsnd[(v_{to},v_{frm}) \mapsto v_c +1] \\ \epsnd(v_{to},\ast) = v_i \\ \epsnd^{\prime\prime} = \epsnd^\prime[(v_{to},\ast) \mapsto v_i +1] 
}{
  ((\thread_0\ \ldots\ ((\sendi\ v_{frm}\ v_{to})\ \cmd_1\ \ldots\ \bot)\ \thread_2\ \ldots)\ (\thread_0^\prime\ \ldots\ (\cmd_2\ \ldots\ \bot)\ \thread_2^\prime\ \ldots)\ \epsnd\ \eprcv\ \epwait\ \epbarrier\ \rcvp)\\ \reduce{m}
  ((\thread_0\ \ldots\ (\cmd_1\ \ldots\ \bot)\ \thread_2\ \ldots)\ (\thread_0^\prime\ \ldots\ (\cmd_2\ \ldots\ (\sendi\ v_{frm}\ v_{to})\ \bot)\ \thread_2^\prime\ \ldots)\ \epsnd^{\prime\prime}\ \eprcv\ \epwait\ \epbarrier\ \rcvp)
}

\and

\inferrule[Rcvi Command]{
 \epwait(\aid_w) =  ([\aid_1\ v_{frm1}\ v_{to1}]\ \ldots)
 \\ \epwait^\prime = \epwait [ \aid_w \mapsto ([\aid_0\ v_{frm0}\ v_{to0}]\ [\aid_1\ v_{frm1}\ v_{to1}]\ \ldots])] 
}{
  ((\thread_0\ \ldots\ ((\recvi\ \aid_0\ v_{frm0}\ v_{to0}\ \aid_w)\ \cmd_1\ \ldots\ \bot)\ \thread_2\ \ldots)\ (\thread_0^\prime\ \ldots\ (\cmd_2\ \ldots\ \bot)\ \thread_2^\prime\ \ldots)\ \epsnd\ \eprcv\ \epwait\ \epbarrier\ \rcvp) \\ \reduce{m}
  ((\thread_0\ \ldots\ (\cmd_1\ \ldots\ \bot)\ \thread_2\ \ldots)\ (\thread_0^\prime\ \ldots\ (\cmd_2\ \ldots\ (\recvi\ \aid_0\ v_{frm0}\ v_{to0}\ \aid_w)\ \bot)\ \thread_2^\prime\ \ldots)\ \epsnd\ \eprcv\ \epwait^\prime\ \epbarrier\ \rcvp)
}
\and
\inferrule[Wait (rcvi) Command 1]
{
  \epwait(\aid_w) = ()
}{
  ((\thread_0\ \ldots\ ((\wait\ \aid_w\ \aid_0)\ \cmd_1\ \ldots\ \bot)\ \thread_2\ \ldots)\ (\thread_0^\prime\ \ldots\ (\cmd_2\ \ldots\ \bot)\ \thread_2^\prime\ \ldots)\ \epsnd\ \eprcv\ \epwait\ \epbarrier\ \rcvp)\\ \reduce{m}
  ((\thread_0\ \ldots\ (\cmd_1\ \ldots\ \bot)\ \thread_2\ \ldots)\ (\thread_0^\prime\ \ldots\ (\cmd_2\ \ldots\ (\wait\ \aid_w\ \aid_0)\ \bot)\ \thread_2^\prime\ \ldots)\ \epsnd\ \eprcv\ \epwait\ \epbarrier\ \rcvp)
}
\and
\inferrule[Wait (rcvi) Command 2]
{
   \epwait(\aid_w) = ([\aid_2\ v_{frm2}\ v_{to2}]\ [\aid_3\ v_{frm3}\ v_{to3}]\ \ldots\ [\aid_1\ v_{frm1}\ v_{to1}])\ \rcvp = (\aid_a\ \ldots\ \aid_b\ \aid_2\ \aid_c\ \ldots) \\ \aid_2 \in \rcvp \\ \rcvp^\prime = (\aid_a\ \ldots\ \aid_b\ \aid_c\ \ldots)
}{
  ((\thread_0\ \ldots\ ((\wait\ \aid_w\ \aid_0)\ \cmd_1\ \ldots\ \bot)\ \thread_2\ \ldots)\ ctp_s\ \epsnd\ \eprcv\ \epwait\ \epbarrier\ \rcvp)\\ \reduce{m}
  ((\thread_0\ \ldots\ ((\wait\ \aid_w\ \aid_0)\ \cmd_1\ \ldots\ \bot)\ \thread_2\ \ldots)\ ctp_s\ \epsnd\ \eprcv\ \epwait\ \epbarrier\ \rcvp^\prime)
}
\and
\inferrule[Wait (rcvi) Command 3]
{
  \epwait(\aid_w) = ([\aid_2\ v_{frm2}\ v_{to2}]\ [\aid_3\ v_{frm3}\ v_{to3}]\ \ldots\ [\aid_1\ v_{frm1}\ v_{to1}]) \\
  \aid_2 \notin \rcvp \\ \eprcv(v_{to2},v_{frm2}) < \epsnd(v_{to2},v_{frm2}) \\ \eprcv(v_{to2},\ast) < \epsnd(v_{to2},\ast) \\
   \eprcv(v_{to2},v_{frm2}) = v_c \\
    \eprcv^\prime = \eprcv [(v_{to2}, v_{frm2}) \mapsto v_c + 1]] \\ 
    \epwait^\prime = \epwait [\aid_w\ \mapsto\ ([\aid_3\ v_{frm3}\ v_{to3}]\ \ldots\ [\aid_1\ v_{frm1}\ v_{to1}])]
}{
  ((\thread_0\ \ldots\ ((\wait\ \aid_w\ \aid_1)\ \cmd_1\ \ldots\ \bot)\ \thread_2\ \ldots)\ ctp_s\ \epsnd\ \eprcv\ \epwait\ \epbarrier\ \rcvp)\\ \reduce{m}
  ((\thread_0\ \ldots\ ((\wait\ \aid_w\ \aid_1)\ \cmd_1\ \ldots\ \bot)\ \thread_2\ \ldots)\ ctp_s\ \epsnd\ \eprcv^\prime\ \epwait^\prime\ \epbarrier\ \rcvp)
}
\and
\inferrule[Barrier Command 1]
{
  \epbarrier(\aid_0) = v_c \\ v_c < \npro \\ \epbarrier^\prime = \epbarrier[\aid_0 \mapsto  v_c + 1]
}{
 ((\thread_0\ \ldots\ ((\barrier\ \num_0\ \aid_0)\ \cmd_1\ \ldots\ \bot)\ \thread_2\ \ldots)\ ctp_s\ \epsnd\ \eprcv\ \epwait\ \epbarrier\ \rcvp)\\ \reduce{m}
 ((\thread_0\ \ldots\ ((\barrier\ \num_0\ \aid_0)\ \cmd_1\ \ldots\ \bot)\ \thread_2\ \ldots)\ ctp_s\ \epsnd\ \eprcv\ \epwait\ \epbarrier^\prime\ \rcvp)
}
\and
\inferrule[Barrier Command 2]
{
  \epbarrier(\aid_0) = \npro
}{
 ((\thread_0\ \ldots\ ((\barrier\ \num_0\ \aid_0)\ \cmd_1\ \ldots\ \bot)\ \thread_2\ \ldots)\ (\thread_0^\prime\ \ldots\ (\cmd_2\ \ldots\ \bot)\ \thread_2^\prime\ \ldots)\ \epsnd\ \eprcv\ \epwait\ \epbarrier\ \rcvp)\\ \reduce{m}
 ((\thread_0\ \ldots\ (\cmd_1\ \ldots\ \bot)\ \thread_2\ \ldots)\ (\thread_0^\prime\ \ldots\ (\cmd_2\ \ldots\ (\barrier\ \num_0\ \aid_0)\ \bot)\ \thread_2^\prime\ \ldots)\ \epsnd\ \eprcv\ \epwait\ \epbarrier\ \rcvp)
}

\end{mathpar}}
\caption{Machine Reductions ($\reduce{m}$). }
\label{fig:machine}
\end{figure*}


The function $\mathrm{SCHEDULEFINDER}$ in \algoref{algo:main} is presented as set of rewriting commands for the machine state (\textit{st}) defined in \figref{fig:machine}. These commands define how to execute the program $\mathit{ctp}$ and generates a schedule $\mathit{ctp}_s$. The \emph{Sndi Command} in \figref{fig:machine} consumes the first send in any process of the program. 
%Consider a portion of the \emph{Sndi Command}:
%\begin{eqnarray*}
% \epsnd(v_{to},v_{frm}) = v_c\\ \epsnd^\prime = \epsnd[(v_{to},v_{frm}) \mapsto v_c +1] \\ \epsnd(v_{to},\ast) = v_i \\ \epsnd^{\prime\prime} = \epsnd^\prime[(v_{to},\ast) \mapsto v_i +1] 
%\end{eqnarray*}
$\epsnd^\prime$\ is a new set, just like the old set $\epsnd$, only the new set maps the destination
endpoint $v_{to}$\ and the source endpoint $v_{frm}$ to the number $v_c + 1$ where $v_c$ is the content in the old set. The set is also updated such that it maps $v_{to}$\ and $\ast$ indicating any source to the number $v_i + 1$ where $v_i$ is the content in the old set. The send is then pushed to the schedule $\mathit{ctp}_s$ at the bottom of the corresponding process in the machine state. The \emph{Rcvi Command} in \figref{fig:machine} consumes the receive by updating the set \epwait. Similar to the rule in \emph{Sndi Command}, \epwait\ merely adds a new record for the receive that is indexed by its nearest-enclosing wait. The receive is then moved to the schedule. The \emph{Wait (Rcvi) Command} operates in three ways. If the wait $\aid_w$ maps to an empty set in \epwait\ indicating that no receives need to be completed by $\aid_w$, then the command consumes $\aid_w$ by moving it to the schedule. If the first receive $\aid_2$ in $\epwait(\aid_w)$ is stored in \rcvp\ for the pattern instance $\mathit{pt}$, then $\aid_2$ is removed from \rcvp\ indicating that it is witnessed. As a note, \algoref{algo:main} checks if all the receives in \rcvp\ are witnessed after detecting a schedule for $\mathit{pt}$. The last way that a wait can move forward checks whether the first receive $\aid_2$\ in $\epwait(x_w)$ is able to be consumed. Note that the receives in $\epwait(\aid_0)$ are ordered as they are on the original process of the program. Therefore, if the first receive in $\epwait(x_w)$ cannot be consumed, the following receives are blocked as well. This step requires two conditions. First, $\aid_2$ is not a receive in the pattern instance. Second, there are more sends than receives with common source and destination endpoints and there are more sends for the preceding wildcard receives. If both conditions are satisfied, then the set \eprcv\ is updated where the new set maps the destination endpoint $v_{to}$\ and the source endpoint $v_{frm}$ to the number $v_c + 1$ where $v_c$ is the content in the old set. This receive is then removed from \epwait. The \emph{Barrier Command} moves the barrier forward by its synchronization rule. If the count of the witnessed barriers $\epbarrier(\aid_0)$ for a specific communicator $\aid_0$ is less than the size of processes $N_{pro}$ indicating that the barriers for $\aid_0$ are not matched, then the barrier is not consumed and $\epbarrier(\aid_0)$ is incremented. The barrier can only be moved to the schedule if the count $\epbarrier(\aid_0)$ is equal to the number of processes $N_{pro}$.

The machine rewrites the state \textit{st} until no more reduction rules can be applied indicating that there is no way to further traverse the program. In such a schedule, the last statement on any process is either the bottom of the process or a blocking operation. A blocking operation could be a wait or a barrier. 

\subsection{Correctness}

\algoref{algo:main} is sound meaning any reported deadlock in \algoref{algo:main} implies a real deadlock in program execution. The soundness is formally established by \lemmaref{lemma:mismatch} and \lemmaref{lemma:circular}.

\begin{lemma}[Soundness for Mismatched Send and Receive Pattern]
For any message passing program, \textit{ctp}, a satisfying assignment returned by the function $\mathrm{ENCODE}$ in \algoref{algo:main} indicates a real deadlock schedule for an instance of the mismatched send and receive pattern, $\mathit{pt}$. 
\label{lemma:mismatch}
\end{lemma}
\begin{proof}
Proof by showing the existence of a deadlock. First, assume $(\mathit{ctp}^\prime,$ $\mathit{ctp}_s,$ $\mathit{N_s},$ $\mathit{N_r},$ $\mathit{P_r},$ $\mathit{P_b},$ $\mathit{R_{pt}}^\prime)$ is the machine state after applying the operational semantics in \figref{fig:machine} and no reduction commands can be further applied. Second, assume the schedule $\mathit{ctp}_s$ is input to the function $\mathrm{ENCODE}$ in \algoref{algo:main}. Since $\mathrm{ENCODE}$ returns a satisfying assignment, say $\mathit{t}$, it implies that $\mathit{t}$ is a sequential order of all the operations in $\mathit{ctp}_s$ that is executable by the runtime system. Also, for the process that the deterministic receive $\mathtt{r_c}$ in $\mathit{pt}$ resides in, say $\mathit{p}$, $\mathit{t}$ satisfies that each send with the destination $\mathit{p}$ is matched with some receive in $\mathit{ctp}_s$. As such, no sends can match $\mathtt{r_c}$ as the nearest-enclosing wait for $\mathtt{r_c}$ is stored in $\mathit{ctp}^\prime$ according to the \emph{Wait (Rcvi) Command 2} in \figref{fig:machine}. Further, for any process other than $\mathit{p}$ in $\mathit{pt}$, the first operation is blocked in $\mathit{ctp}^\prime$ according to the operational semantics in \figref{fig:machine}. As such, $\mathit{ctp}^\prime$ deadlocks. Since $\mathit{ctp}_s$ is executable and $\mathit{ctp}^\prime$ deadlocks, the program \textit{ctp} may deadlock for the pattern instance $\mathit{pt}$ in program execution. 
\end{proof}

\begin{lemma}[Soundness for Circular Dependency Pattern]
For any message passing program, \textit{ctp}, the existence of a deadlock reported by \algoref{algo:main} for an instance of the circular dependency pattern, $\mathit{pt}$, indicates a real deadlock. 
\label{lemma:circular}
\end{lemma}
\begin{proof}
Proof by showing the existence of a deadlock. First, assume $(\mathit{ctp}^\prime,$ $\mathit{ctp}_s,$ $\mathit{N_s},$ $\mathit{N_r},$ $\mathit{P_r},$ $\mathit{P_b},$ $\mathit{R_{pt}}^\prime)$ is the machine state after applying the operational semantics in \figref{fig:machine} and no reduction commands can be further applied. Second, assume \algoref{algo:main} reports the existence of a deadlock at line $15$. Assume $\mathit{ctp}_s$ is a feasible schedule. Similar to the proof of \lemmaref{lemma:mismatch}, $\mathit{ctp}_s$ is executable in the runtime system. Also, any receive in $\mathit{pt}$ has no way to be matched if the condition at line $11$ in \algoref{algo:main} is not satisfied for any receive in $\mathit{pt}$. Further, for any process other than the processes in $\mathit{pt}$, the first operation is blocked in $\mathit{ctp}^\prime$ according to the operational semantics in \figref{fig:machine}. As such, $\mathit{ctp}^\prime$ deadlocks. As such, the program \textit{ctp} may deadlock for the pattern instance $\mathit{pt}$ in program execution. 
\end{proof}

\algoref{algo:main} is also complete for the two deadlock patterns. 

\begin{lemma}[Completeness for Two Common Deadlock Patterns]
For any message passing program, \textit{ctp}, any real deadlock for mismatched send and receive pattern and circular dependency pattern can be reported by \algoref{algo:main}.
\label{lemma:complete}
\end{lemma}
\begin{proof}
Proof by showing that the operational semantics in \figref{fig:machine} simulate the message communication under infinite buffer semantics. For \emph{Sndi Command} and \emph{Rcvi Command}, a send or receive is consumed immediately by incrementing two structures $\mathit{N_s}$ and $\mathit{N_r}$, respectively. This is consistent with the issuing of send and receive under infinite buffer semantics. The three cases of \emph{Wait Command} witness the completion of receives that are not in the pattern $\mathit{pt}$ and hold the receives in $\mathit{pt}$ so that a postponed feasibility check is launched in \algoref{algo:main}. The two cases of \emph{Barrier Command} stops the execution of a member process until all the barriers in group are witnessed. Since the operational semantics in \figref{fig:machine} are able to simulate the behavior under infinite buffer semantics, if a real deadlock exists for a pattern, then the schedule is able to be extracted. Thus, the deadlock can be reported.
\end{proof}

As a note, \algoref{algo:main} is not complete because there might exist other deadlock patterns that cause a message passing program deadlock. Therefore, a reported deadlock free program may have a deadlock for other patterns. The completeness, however, can be proved if all the deadlock patterns are extended to \algoref{algo:main}. 

 
 %The completeness is established by \lemmaref{lemma:completeness}.
 
 %\begin{lemma}[Completeness]
 %For any message passing program, \textit{ctp}, that may deadlock for mismatched send-receive pattern or circular dependency pattern, \algoref{algo:main} reports a deadlock.
% \label{lemma:completeness}
 %\end{lemma}
 %\begin{proof}
 %Proof by two steps. The first step proves that all the pattern instances are detected. For the mismatched send-receive pattern, since the algorithm traverses every process and detects all the deterministic receives that satisfy the properties of \defref{def:mismatch}, all the pattern instances are detected. For the circular dependency pattern, the algorithm adds all the receives and sends that may be contained in sequential relations defined in \defref{def:seqrelation} to the vertices $\mathit{V}$. It also adds the over-approximated match relations and all possible happens-before relations that satisfy the properties of \defref{def:circular} to the edges $\mathit{E}$. Further, the Johnson's algorithm is able to detect all the cycles given $\mathit{V}$ and $\mathit{E}$. As such, all the pattern instances are detected.
%The second step proves that if there are a set of pattern instances, \textit{PT}, for \textit{ctp} such that each instance may cause a real deadlock, at least one deadlock is detected. There are two cases for any pattern instance $\mathit{pt}\in\mathit{PT}$. First, if a deadlock is reported for $\mathit{pt}$, the statement above holds. Second, no deadlock is reported for $\mathit{pt}$ but there is a real deadlock for it. This is because either no schedule is detected but one actually exists, or the schedule detected is infeasible for the mismatched send-receive pattern. Under either situation, a ``bogus" schedule is detected but is pruned by \algoref{algo:main}. Notice that the operational semantics in \figref{fig:machine} determines if a receive can be matched with the rule of ``\emph{Wait (Rcvi) Command 3}" in \figref{fig:machine}. For any wildcard receive $\mathtt{r_w}$, if the condition holds, then $\mathtt{r_w}$ can also be matched in runtime. For any deterministic receive $\mathtt{r_c}$, if this condition holds, $\mathtt{r_c}$ may not be matched because the schedule has to match all the available sends with the preceding wildcard receives on a single process. If this happens, a ``bogus" schedule exists with a real deadlock for the mismatched send-receive pattern instance $\{\mathtt{r_c}\}$. Since all the pattern instances are detected, the pattern instance $\{\mathtt{r_c}\}$ is eventually checked. There are only two cases for any pattern instance. It is not possible that each pattern instance has a real deadlock in its ``bogus" schedule. As such, at least one deadlock is detected for some pattern instance. Therefore, the statement above holds.
%Since all the pattern instances are detected and at least one deadlock is detected if real deadlocks exists for those pattern instances, the completeness is proved. $\Box$
%\end{proof}

\subsection{Deadlock for Zero Buffer Semantics}
The deadlock patterns discussed above may also cause a program to deadlock under zero buffer semantics. Notice that the commands in \figref{fig:machine} are consistent with how messages communicate under infinite buffer semantics (e.g., a send is consumed immediately). The zero buffer semantics, however, enforce a different way of message communication. As such, a feasible infinite buffer schedule generated by \algoref{algo:main} is not able to witness a deadlock under zero buffer semantics. Therefore, the zero buffer compatibility should be checked for each generated schedule. \algoref{algo:main} is extended with two changes: 1) the zero buffer encoding rules (refer to \cite{HuangNFM15}) are added to the function $\mathrm{ENCODE}$; 2) The circular dependency pattern also needs an SMT encoding to check the feasibility of a schedule. As a note, to encode the match pairs for the circular dependency pattern only needs to ensure that each receive in the schedule is matched with some send. Once the schedule is proved to be zero buffer compatible, the program may deadlock under zero buffer semantics; otherwise, the pattern instance does not imply a real deadlock. 

%\examplefigfive

%Notice that the zero buffer semantics may cause a deadlock in a different way other than the patterns discussed above. For instance, the program in \figref{fig:zeropattern} deadlocks under zero buffer semantics if the send at line \texttt{20} matches the receive at line \texttt{00}. There is no way to match the send at line \texttt{02} or the send at line \texttt{10}. This program does not contain either pattern discussed in this paper. To check this type of deadlock needs to define deadlock patterns merely for zero buffer semantics. These patterns, however, are hard to be completely defined because all sends are blocking operations under zero buffer semantics. A deadlock may randomly occur in the way of message communication and a new pattern can be formed. Future work explores to detect this type of deadlock.


