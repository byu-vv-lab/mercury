\section{Conclusion and Future Work}
This paper presents a new algorithm that uses static analysis to detect a deadlock for a message passing program based on two types of deadlock patterns: mismatched send and receive pattern and circular dependency pattern. The key insight in this paper is pruning all the infeasible pattern instances from a set of potential deadlocks by checking the feasibility of a schedule. In particular, statically traversing a program is sufficient to detect a deadlock for the circular dependency pattern. For the mismatched send and receive pattern, an SMT encoding is further required. The complexity of the algorithm is quadratic. This paper also proves that the algorithm is sound meaning every deadlock detected is a real deadlock that may occur in the runtime system. Further, the algorithm can be modified to check deadlocks for these two patterns under zero buffer semantics. Experiments demonstrate that the algorithm in this paper is correct and more efficient than two state-of-art MPI verifiers.

The deadlock for a message passing program may be caused by some pattern other than the two patterns discussed in this paper. In particular, many deadlock patterns can be formed merely for zero buffer semantics. Therefore, future work will explore defining other deadlock patterns and using static analysis to find deadlocks for all the pattern instances. 

\newpage